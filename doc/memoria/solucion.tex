\chapter{Solución}\label{solucion}
\lhead{Capítulo \ref{solucion}}
\rhead{Solución}
%*******************************************************************************
% *************************************************************************************************************** %
% 			SOLUCIÓN
% *************************************************************************************************************** %

	%\begin{figure}[htbp]
		%\centering
			%\includegraphics[width=1\textwidth]{imgs/sistema.png}
		%\caption{Diagrama de flujo del Sistema}
		%\label{fig:sistema}
	%\end{figure}
	%
	%\begin{figure}[htbp]
		%\centering
			%\includegraphics[width=0.60\textwidth]{imgs/flujoUsuario.jpg}
		%\caption{Esquema del flujo que sigue el votante}
		%\label{fig:flujoUsuario}
	%\end{figure}
	%\begin{figure}[htbp]
		%\centering
			%\includegraphics[width=0.60\textwidth]{imgs/flujoSistema.jpg}
		%\caption{Esquema del flujo del Sistema}
		%\label{fig:flujoSistema}
	%\end{figure}
		
			
		\section{Arquitectura del sistema}\label{solucion_arquitectura}
			Tal como se determina en el análisis (\ref{analisis}), la solución que se propone para este Proyecto consiste en la integración de tres componentes, adaptados a las necesidades de una elección para la EPS.
			
			\begin{description}
				\item[Cliente:] Para permitir el acceso del usuario al sistema utilizando el \gls{DNIe} 3.0, se ha implementado una solución para poder acceder a las credenciales del chip sin contacto del documento. Este desarrollo es una aplicación Android, basada en una de ejemplo compartida por la Policía. Además de la app cliente, tanto el sistema de autenticación como el de votación ofrecen una interfaz web para interactuar con el usuario a través de navegadores web.
			
				\item[Sistema de autenticación:] Para permitir el acceso al sistema con las credenciales del DNIe, se utiliza un sistema de autenticación basado en el protocolo oAuth2. El usuario accede a través de un navegador web o de la app Android desarrollada por HTTPS/TLS de forma segura al servidor web. Se establece un canal seguro utilizando el certificado del propio servidor y como certificado de cliente, el de identificación del DNIe. Este sistema es el que autoriza al usuario comprobando su identidad y consultando su presencia en el censo de la elección.
			
				\item[Sistema de votación:] El sistema de votación es una versión adaptada del sistema Helios Voting. Se comunica con el cliente (y con el sistema de autenticación) por HTTPS y el usuario, autorizado previamente, tiene la posibilidad de, dependiendo de su rol, crear y gestionar una elección, votar en ella y/o, simplemente, consultar los resultados.
			\end{description}
			
			\begin{figure}[!ht]
				\centering
					\includegraphics[width=.95\textwidth]{imgs/arquitecturaSistema00.jpg}
				\caption{Arquitectura general del sistema}
				\label{fig:arquitectura.sistema.0}
			\end{figure}
			
			
			
		\section{Sistema de autenticación}\label{arquitectura_servidorAutenticacion}
			El Sistema de Autenticación implementa el protocolo de autenticación oAuth 2.0 entre el usuario y el sistema. En concreto, se ha realizado un fork del proyecto \textit{django-oauth2-server}\footnote{\url{https://github.com/RichardKnop/django-oauth2-server}} desarrollado por Richard Knop. El objetivo era modificarlo para adaptarlo a diferentes necesidades teniendo en cuenta si el acceso es por la web o a través de la app Android. Además, era necesario que la autorización del usuario se realizara consultando el censo de usuarios y/o votantes de la Elección.
		 
			El sistema de autenticación se compone de un servidor web, el sistema de oAuth basado en Django que hemos comentado y una base de datos que contiene tanto permisos de aplicaciones y usuario como los propios usuarios con permiso de acceso al sistema de votación.
	
			
	
			El servidor web se configura para exponer un endpoint de entrada seguro, permitiendo el acceso por HTTPS. En dicha configuración es muy importante activar diversas características:
			
			\subsection{Servidor web:}
				El canal de comunicación entre el usuario y el sistema de autenticación es la web, el protocolo es HTTPS y la herramienta que gestiona estos accesos es el servidor web.
				
				Con el fin de establecer un canal HTTPS seguro entre usuario y servidor, es necesario que en su configuración se contemplen tres certificados, dos de ellos en posesión del servidor y el tercero de obligada presentación por parte del cliente.
				
				\begin{description}
					\item[Certificado de servidor:] Es el certificado que permite al navegador negociar el establecimiento de la conexión segura. Si se ha obtenido de algún proveedor confiable, el navegador lo gestiona de forma casi transparente al usuario. Sin embargo, si la fuente no es confiable y no se encuentra en el almacén de certificados del sistema operativo o el navegador, se muestra una advertencia al usuario aconsejándole que no continúe la navegación, aunque le permite seguir adelante a riesgo del usuario. Es lo que ocurre también cuando se utiliza un certificado autofirmado.
					
					En nuestro caso, se ha decidido utilizar un certificado autofirmado para el prototipo implementado. Los pasos necesarios tanto para crear y firmar el certificado como para configurar el servidor web para que lo utilice se pueden consultar en el anexo \ref{App:ConfiguracionServidorWeb}.
					
					\item[Certificado AC Raíz DGP:] Es el certificado que permite al Sistema Operativo y al navegador web reconocer la Autoridad de Certificación de los certificados de sede electrónica, la AC Raíz DGP, que son los encargados de generar los certificados que se incluyen en el DNIe 3.0.
					
					\item[Certificado de cliente:] Para utilizar el DNIe como fuente de identificación del usuario, es preciso configurar el servidor web para que requiera en la conexión la presencia del certificado de autenticación del DNIe del usuario. Para ello, el servidor debe poseer el certificado raíz que provee la Dirección General de la Policía. Este certificado se configura en el servidor
					
				\end{description}
				
				Además de configurar el servidor para que requiera el certificado de cliente SSL, es necesario aplicar la configuración necesaria para pasar la información a la aplicación que la necesita.
				
				Para ello, el servidor web ha de exportar los datos del certificado SSL a variables de entorno.
				
				Cuando se recibe una petición al servidor, éste inyecta estas variables en la request que hace llegar al código. Concretamente, en Python (Django) son accesibles desde el META de la request. 
				
				En el siguiente código podemos ver una función que atiende una petición GET a la vista de autorización para mostrar una lista de variables asociadas a la seguridad del servidor que recibe de éste:
						
\begin{lstlisting}[language=Python, caption=Variables SSL que recibe el servidor web de autenticación.]
class AuthorizeView(View):
  form_class = AuthorizeForm
  initial = {}
  template_name = 'web/authorize.html'

  @method_decorator(validate_request)
  def dispatch(self, *args, **kwargs):
      return super(AuthorizeView, self).dispatch(*args, **kwargs)

  def get(self, request, *args, **kwargs):
      form = self.form_class(initial=self.initial)
      try:
        claves = [
            'SSL_PROTOCOL'
            ,'SSL_SESSION_RESUMED'
            ,'SSL_SECURE_RENEG'
            ,'SSL_CIPHER'
            ,'SSL_CIPHER_EXPORT'
            ,'SSL_CIPHER_USEKEYSIZE'
            ,'SSL_CIPHER_ALGKEYSIZE'
            ,'SSL_COMPRESS_METHOD'
            ,'SSL_VERSION_INTERFACE'
            ,'SSL_VERSION_LIBRARY'
            ,'SSL_CLIENT_M_VERSION'
            ,'SSL_CLIENT_M_SERIAL'
            ,'SSL_CLIENT_S_DN'
            ,'SSL_CLIENT_I_DN'
            ,'SSL_CLIENT_V_START'
            ,'SSL_CLIENT_V_END'
            ,'SSL_CLIENT_V_REMAIN'
            ,'SSL_CLIENT_A_SIG'
            ,'SSL_CLIENT_A_KEY'
            ,'SSL_CLIENT_CERT'
            ,'SSL_CLIENT_VERIFY'
            ,'SSL_SERVER_M_VERSION'
            ,'SSL_SERVER_M_SERIAL'
            ,'SSL_SERVER_S_DN'
            ,'SSL_SERVER_I_DN'
            ,'SSL_SERVER_V_START'
            ,'SSL_SERVER_V_END'
            ,'SSL_SERVER_A_SIG'
            ,'SSL_SERVER_A_KEY'
            ,'SSL_SERVER_CERT'
            ]
        for k in claves:
          try:
            logger.warn(k+': '+str(request.META[k]))
          except Exception as ex:
            logger.warn('El objeto no tiene la clave *' + k + '* --- ' + ex)

        dnie = get_dni_info_from_ssl(request)
      except Exception as e:
        logger.warn('get_No vienen las credenciales del DNIe')

      return self._render(request=request, form=form, dnie=dnie)
\end{lstlisting}

				En la lista se observa una gran cantidad de variables de entorno relacionadas con la seguridad del servidor.
				
				A continuación se muestra la ejecución de ese código para ver los valores que se devuelven y recogen del certificado, como ejemplo:
\begin{lstlisting}
  2017-01-09 18:23:10,163 DEBUG prueba: *CN=JIMÉNEZ GÓMEZ\, JOSÉ CARLOS (AUTENTICACIÓN),GN=JOSÉ CARLOS,SN=JIMÉNEZ,serialNumber=53159931P,C=ES*
  2017-01-09 18:23:10,165 DEBUG SSL_PROTOCOL: TLSv1.2
  2017-01-09 18:23:10,167 DEBUG SSL_SESSION_RESUMED: Initial
  2017-01-09 18:23:10,170 DEBUG SSL_SECURE_RENEG: true
  2017-01-09 18:23:10,172 DEBUG SSL_CIPHER: ECDHE-RSA-AES128-GCM-SHA256
  2017-01-09 18:23:10,174 DEBUG SSL_CIPHER_EXPORT: false
  2017-01-09 18:23:10,176 DEBUG SSL_CIPHER_USEKEYSIZE: 128
  2017-01-09 18:23:10,178 DEBUG SSL_CIPHER_ALGKEYSIZE: 128
  2017-01-09 18:23:10,180 DEBUG SSL_COMPRESS_METHOD: NULL
  2017-01-09 18:23:10,182 DEBUG SSL_VERSION_INTERFACE: mod_ssl/2.4.10
  2017-01-09 18:23:10,184 DEBUG SSL_VERSION_LIBRARY: OpenSSL/1.0.1t
  2017-01-09 18:23:10,186 DEBUG SSL_CLIENT_M_VERSION: 3
  2017-01-09 18:23:10,188 DEBUG SSL_CLIENT_M_SERIAL: 1753616228212A66BD1AB7E719BC5613
  2017-01-09 18:23:10,191 DEBUG SSL_CLIENT_S_DN: CN=GORDILLO CARDEÑOSA\, ALFONSO (AUTENTICACIÓN),GN=ALFONSO,SN=GORDILLO,serialNumber=11062005B,C=ES
  2017-01-09 18:23:10,193 DEBUG SSL_CLIENT_I_DN: CN=AC DNIE 001,OU=DNIE,O=DIRECCION GENERAL DE LA POLICIA,C=ES
  2017-01-09 18:23:10,195 DEBUG SSL_CLIENT_V_START: Jun 11 12:26:58 2016 GMT
  2017-01-09 18:23:10,197 DEBUG SSL_CLIENT_V_END: Mar 15 22:59:59 2021 GMT
  2017-01-09 18:23:10,199 DEBUG SSL_CLIENT_V_REMAIN: 1510
  2017-01-09 18:23:10,201 DEBUG SSL_CLIENT_A_SIG: sha256WithRSAEncryption
  2017-01-09 18:23:10,203 DEBUG SSL_CLIENT_A_KEY: rsaEncryption
  2017-01-09 18:23:10,205 DEBUG SSL_CLIENT_CERT: -----BEGIN CERTIFICATE-----
  TUlJRjh6Q0NCTnVnQXdJQkFnSVFJc1hvYW54bE5oQllORG1TSU85a1BUQU5CZ2tx
  aGtpRzl3MEJBUXNGQURCYwpNUXN3Q1FZRFZRUUdFd0pGVXpFb01DWUdBMVVFQ2d3
  ZlJFbFNSVU5EU1U5T0lFZEZUa1ZTUVV3Z1JFVWdURUVnClVFOU1TVU5KUVRFTk1B
  c0dBMVVFQ3d3RVJFNUpSVEVVTUJJR0ExVUVBd3dMUVVNZ1JFNUpSU0F3TURFd0ho
  Y04KTVRZeE1USXlNVEl5TmpVNFdoY05NakV3TWpJMk1qSTFPVFU1V2pDQmhERUxN
  QWtHQTFVRUJoTUNSVk14RWpBUQpCZ05WQkFVVENUVXpNVFU1T1RNeFVERVJNQThH
  QTFVRUJBd0lTa2xOdzRsT1JWb3hGVEFUQmdOVkJDb01ERXBQClU4T0pJRU5CVWt4
  UFV6RTNNRFVHQTFVRUF3d3VTa2xOdzRsT1JWb2dSOE9UVFVWYUxDQktUMVBEaVNC
  RFFWSk0KVDFNZ0tFRlZWRVZPVkVsRFFVTkp3NU5PS1RDQ0FTSXdEUVlKS29aSWh2
  Y05BUUVCQlFBRGdnRVBBRENDQVFvQwpnZ0VCQUpYcmVxMTV6R0xnMmcwbW5hcmlN
  U1pUU05ZRTBDVnlhaEw1R3ZydGZjRHlxSUY2SHgvWkxtY2R1ck5yCkd4cUlXYktz
  amk1Z01pTFVueFowVWdpcGVqN3RyRVp4NDBObW40RmxqZ2lzcmgzMWtpNWtBQ2Rj
  elBYaE9sN20KVThNK2ZTeXZMVUd1TmN1SUhUYkJGcWV3UWtJNTVydklIZ2x5MjVQ
  WjZoakczSUJQRThEckZOd0ZUbkN3NXFmYgp6TCs2ZFdXaFpjd2JaZk5rV3FsdUN0
  emhFRG5PaWJMNkp1c0s3VnhSNE1zc2dRYWZoUnVSdmdyeHJsNGFINXNsCjlGc3l0
  ZlIvNmNpVHhGMmtremhDZ05GNlluNit4TGo0T3NoVXh3dVo4NHRsM1A5NndrcTRH
  eGx5V21QSWJhTDMKdFMzQmcwaGdVS3Q4cmFVNy8rQW4rc2hMaDhFQ0F3RUFBYU9D
  QW9Zd2dnS0NNQXdHQTFVZEV3RUIvd1FDTUFBdwpEZ1lEVlIwUEFRSC9CQVFEQWdl
  QU1CMEdBMVVkRGdRV0JCUWlwbUlVRTJwYnh1NG5xN0tUbWhUaU9MTDFRVEFmCkJn
  TlZIU01FR0RBV2dCUWFpYWpGN285MlhWVnhpZk03TmIycUJRQ1ZiekFpQmdnckJn
  RUZCUWNCQXdRV01CUXcKQ0FZR0JBQ09SZ0VCTUFnR0JnUUFqa1lCQkRCZ0JnZ3JC
  Z0VGQlFjQkFRUlVNRkl3SHdZSUt3WUJCUVVITUFHRwpFMmgwZEhBNkx5OXZZM053
  TG1SdWFXVXVaWE13THdZSUt3WUJCUVVITUFLR0kyaDBkSEE2THk5M2QzY3VaRzVw
  ClpTNWxjeTlqWlhKMGN5OUJRMUpoYVhvdVkzSjBNRHNHQTFVZElBUTBNREl3TUFZ
  SVlJVlVBUUlDQWdRd0pEQWkKQmdnckJnRUZCUWNDQVJZV2FIUjBjRG92TDNkM2R5
  NWtibWxsTG1WekwyUndZekNCOEFZSUt3WUJCUVVIQVFJRQpnZU13Z2VBd01nSUJB
  VEFMQmdsZ2hrZ0JaUU1FQWdFRUlOQUF5cDY1VThZT3M3bGxXSnlvZXRBRzVyVVo1
  TTR3CnNaNkl4VnJ0ODlQV01ESUNBUUF3Q3dZSllJWklBV1VEQkFJQkJDQUwvdS9R
  NzZzbit0RWoyRmNIQnlaN0lCRVkKY2xaTmRld1pDUVNnNnVLdmNEQTZCZ2xnaFZR
  QkFnSUVBZ0V3Q3dZSllJWklBV1VEQkFJQkJDQld6Tld3cm0vOQo5d2YrVHNEZXd5
  RnNER21kR0tNS0M2U2I0ck1zSlU5UWxqQTZCZ2xnaFZRQkFnSUVBZ1l3Q3dZSllJ
  WklBV1VECkJBSUJCQ0JXek5Xd3JtLzk5d2YrVHNEZXd5RnNER21k
  -----END CERTIFICATE-----
  
  2017-01-09 18:23:10,207 DEBUG SSL_CLIENT_VERIFY: SUCCESS
  2017-01-09 18:23:10,210 DEBUG SSL_SERVER_M_VERSION: 1
  2017-01-09 18:23:10,212 DEBUG SSL_SERVER_M_SERIAL: 69B5F037577EDB1B 
  2017-01-09 18:23:10,214 DEBUG SSL_SERVER_S_DN: emailAddress=pepe.mel@miservidor.rbb,CN=eleccionesuspceu.com,OU=EPS,O=USP CEU,L=Madrid,ST=Madrid,C=ES
  2017-01-09 18:23:10,216 DEBUG SSL_SERVER_I_DN: emailAddress=pepe.mel@miservidor.rbb,CN=eleccionesuspceu.com,OU=EPS,O=USP CEU,L=Madrid,ST=Madrid,C=ES
  2017-01-09 18:23:10,218 DEBUG SSL_SERVER_V_START: Nov 25 19:47:17 2016 GMT
  2017-01-09 18:23:10,220 DEBUG SSL_SERVER_V_END: Nov 25 19:47:17 2017 GMT
  2017-01-09 18:23:10,222 DEBUG SSL_SERVER_A_SIG: sha256WithRSAEncryption
  2017-01-09 18:23:10,224 DEBUG SSL_SERVER_A_KEY: rsaEncryption
  2017-01-09 18:23:10,226 DEBUG SSL_SERVER_CERT: -----BEGIN CERTIFICATE-----
  wr9RdcOpIGVzIHVuIGNlcnRpZmljYWRvIGVsZWN0csOzbmljbz8KCkVzIHVuIGRv
  Y3VtZW50byBkaWdpdGFsIHF1ZSBjb250aWVuZSwgZW50cmUgb3RyYSBpbmZvcm1h
  Y2nDs24sIGxvcyBkYXRvcyBpZGVudGlmaWNhdGl2b3MgcGVyc29uYWxlcy4gUGVy
  bWl0ZSBpZGVudGlmaWNhcnNlIGVuIGludGVybmV0IGUgaW50ZXJjYW1iaWFyIGlu
  Zm9ybWFjacOzbiBjb24gb3RyYXMgcGVyc29uYXMgY29uIGxhIGdhcmFudMOtYSBk
  ZSBxdWUgc8OzbG8gZWwgdGl0dWxhciBwdWVkZSBhY2NlZGVyIGEgZWxsYS4KCsK/
  UGFyYSBxdcOpIHNpcnZlIHVuIGNlcnRpZmljYWRvIGVsZWN0csOzbmljbz8KCkVs
  IGNlcnRpZmljYWRvIGVsZXRyw7NuaWNvIGdhcmFudGl6YSBsYSBpZGVudGlkYWQg
  ZGVsIHVzdWFyaW8sIGxvIHF1ZSBwZXJtaXRlIHJlYWxpemFyIGxvcyB0csOhbWl0
  ZXMgcXVlIHJlcXVpZXJhbiBpZGVudGlmaWNhY2nDs24gc2VndXJhIHBvciBwYXJ0
  ZSBkZWwgdXN1YXJpby4gUGVybWl0ZSB0YW1iacOpbiBsYSBmaXJtYSBlbGVjdHLD
  s25pY2EgZGUgZm9ybXVsYXJpb3MgeSBkb2N1bWVudG9zIGVsZWN0csOzbmljb3Ms
  IHF1ZSB0aWVuZSBsYSBtaXNtYSB2YWxpZGV6IGp1csOtZGljYSBxdWUgbGEgZmly
  bWEgbWFudXNjcml0YSBlbiBlbCBkb2N1bWVudG8gZW4gcGFwZWwuCgpQcm9ibGVt
  YXMgZGUgbG9zIGNlcnRpZmljYWRvcyBjb24gc3UgbmF2ZWdhZG9yCgpFcyBwb3Np
  YmxlIHF1ZSBhbCBhY2NlZGVyIGEgbGFzIHDDoWdpbmFzIGRlIGxhIFNlZGUgRWxl
  Y3Ryw7NuaWNhLCBzdSBuYXZlZ2Fkb3IgcHJlc2VudGUgdW4gbWVuc2FqZSBtw6Fz
  IG8gbWVub3MgYWxhcm1hbnRlLgoKRXN0ZSBhdmlzbyBpbmRpY2EgcXVlIGVsIHNp
  dGlvIHF1ZSBzZSB2aXNpdGEgbm8gZXMgZGUgY29uZmlhbnphLCBhbCBubyByZWNv
  bm9jZXIgc3UgbmF2ZWdhZG9yIGxhIEF1dG9yaWRhZCBkZSBDZXJ
  -----END CERTIFICATE-----
\end{lstlisting}
				
				Aquellas que comienzan por SSL\_SERVER se refieren a la información del certificado del servidor.
				
				Por su parte, aquellas que comienzan por SSL\_CLIENT son las que contienen la información proporcionada por el certificado presentado por el cliente. En el caso de este proyecto, contendrán los datos proporcionados por el certificado de autenticación del DNIe.
				
				De estas variables, algunas son las que se utilizan para recoger la información del usuario, contrastarlo con el censo de usuarios y poder comprobar qué permisos posee, incluido el de acceso al sistema.
				
				\begin{description}
					\item[SSL\_CLIENT\_S\_DN:] Contiene la información personal del sujeto que identifica el certificado.
						En el ejemplo:
\begin{lstlisting}
  SSL\_CLIENT\_S\_DN: CN=GORDILLO CARDEÑOSA\\, ALFONSO (AUTENTICACIÓN),GN=ALFONSO,SN=GORDILLO,serialNumber=11062005B,C=ES	
\end{lstlisting}
						Así, del certificado de cliente obtenemos:
						\begin{description}
							\item [CN (commonName):] GORDILLO CARDEÑOSA\\, ALFONSO (AUTENTICACIÓN) $\Leftarrow$ Junto con el nombre de la persona identificada por el certificado, se encuentra el tipo de certificado que estamos recibiendo, en este caso, el de AUTENTICACIÓN.
							
							\item [GN (givenName):] ALFONSO
							
							\item [SN (surName):] GORDILLO
							
							\item [serialNumber:] 11062005B $\Leftarrow$ En el caso del DNIe, en serialNumber encontraremos el número del DNI de la persona identificada por el documento.
							
							\item [C (country):] ES $\Leftarrow$ Código del país de expedición del documento según el estándar ISO 3166\footnote{\url{https://es.wikipedia.org/wiki/ISO_3166}}. En este caso, ES\footnote{\url{https://es.wikipedia.org/wiki/ISO_3166-2:ES}} = ESPAÑA.
							
						\end{description}

					
					
					\item[SSL\_CLIENT\_V\_START:] Contiene la fecha de expedición del certificado.
\begin{lstlisting}					
  SSL\_CLIENT\_V\_START: Jun 11 12:26:58 2016 GMT
\end{lstlisting}

					
					
					\item[SSL\_CLIENT\_V\_END:] Contiene la fecha de caducidad del certificado.
\begin{lstlisting}					
  SSL\_CLIENT\_V\_END: Mar 15 22:59:59 2021 GMT
\end{lstlisting}
					
				\end{description}
				
		
		
		
			\subsection{Aplicación de autenticación}
					
				La aplicación recibe del servidor web la información del certificado del cliente a través de los METAS inyectados en el \textit{header} de la \textit{request} por parte del servidor.
				
				La aplicación implementa el flujo oAuth2 en modo Authorization Code. Con la información del usuario que recibe del certificado de cliente, lo identifica y valida los permisos que tiene.
				
				En caso de que la validación sea correcta, genera un token que almacena en la base de datos para comunicar al sistema de votación que el votante tiene permisos de acceso. Además, genera un código de autorización que devuelve al cliente. Este código lo tendrá que presentar el cliente al sistema de votación para entrar al sistema. Una vez el sistema reciba el código, lo utilizará para pedir al sistema de autenticación el token de acceso que mapea la aplicación y los permisos que dispone el usuario. Una vez el sistema de autenticación devuelve el token al de votación, éste tendrá que presentárselo para que aquel le comunique aquellos datos personales que posee del usuario que intenta acceder.
				
				Sigue, por tanto un modelo del flujo de oAuth2, apoyado en una herramienta escrita por Richard Knop en Python sobre un framework Django. No obstante, este código ha servido de base, pues ha debido ser modificado para adaptarlo a las necesidades particulares de este sistema:
					
				\begin{itemize}
				
					\item Se ha modificado el proceso de obtención de datos del usuario, pues, además de obtenerlos de la base de datos, hay que extraer información del usuario de los certificados de cliente que presenta para su identificación.

					\item Se ha modificado el sistema de validación del usuario para que contraste esta información del certificado de autenticación con el censo de la base de datos.

					\item Hay que contrastar la validez del certificado, principalmente si no ha caducado. Además, aunque al final se haya configurado en el servidor, hay que realizar una comprobación contra un servidor \gls{OCSP} para ver si ha sido revocado por la autoridad certificadora.

				\end{itemize}
				
				
				
				
			\subsection{OCSP}
				
				\gls{OCSP} es un servicio de revocación que ofrece la autoridad que crea el certificado raíz, en nuestro caso la \gls{DGP} y la \gls{FNMT}. Estas organizaciones proveen de un servicio al cual conectarse y consultar la validez de los certificados que se estén tratando de autenticar.ñ
				
				Una alternativa al \gls{OCSP} es la de generar una \gls{CRL}. Las ventajas de las listas de revocación consisten en que son más simples que el \gls{OCSP} y pueden ser consultadas sin conexión a la red, lo cual es importante en caso de que el sistema esté configurado de modo que corra sobre una red privada, sin acceso a Internet (ver figura \ref{fig:topologiaRed_intranet} en \ref{solucion_topologiaRed}).
				
				El sistema funciona validando contra la \gls{OCSP} de la \gls{DGP}. La implementación de este sistema se realiza por medio de configuración del servidor web. Es el propio servidor quien realiza la comprobación OCSP del certificado cliente y recibe la validez o no del mismo por parte del del servicio externo.
				
				Cuando el sistema esté configurado para operar sobre una red interna será necesario desactivar esta configuración del servidor web, pues sin acceso a Internet no será posible realizar la comprobación contra el servicio de la autoridad certificadora.
				
			\subsection{Esquema de la base de datos}\label{solucion_servidor_autenticacion_bd}
				En la figura \ref{fig:er.servidor.autenticacion} se presenta el diagrama entidad-relación correspondiente al sistema de autenticación.
				
				En este diagrama se observan dos ámbitos de entidades diferenciados:
				\begin{itemize}
					\item Entidades para gestión de tokens.
					\item Entidades para gestión de autenticación de usuario.
				\end{itemize}
				
				
					\begin{figure}[!ht]
						\centering
							\includegraphics[width=\textwidth]{imgs/oAuthServerER.png}
						\caption{Diagrama ER del Servidor de Autenticación}
						\label{fig:er.servidor.autenticacion}
					\end{figure}
				
								
			\section{Sistema de votación}\label{arquitectura_servidorVotacion}
				El Sistema de Votación es el \textit{core} del sistema. Es el que soporta toda la lógica de la elección.
				
				De cara a los administradores, permite gestionar una Elección desde su creación y definición hasta la publicación de resultados tras el escrutinio.
				
				De cara al votante, le permite acceder a la elección de las alternativas que se le presentan para votar y emitir su voto de forma segura, secreta y anónima, con la seguridad de que no es manipulado y que será correctamente escrutado.
				
				Junto al módulo central de votación, este sistema presenta otros cuatro módulos específicos.
			
				\begin{description}
					\item[Cabina de votación:] Es el módulo que permite a los votantes elegir el voto y cifrarlo. Lo separamos del módulo principal porque se un módulo escrito principalmente en javascript y se ejecuta en el navegador del cliente. Se delega en la máquina del cliente la potencia necesaria para el cifrado de su voto.
					
					\item[Verificador de la elección:] Es un módulo de acceso externo que permite, pasándole la huella digital de una elección que ya haya terminado, la verificación de la integridad de la misma. Así, por medio de funciones criptográficas, asegura que la elección ha sido correctamente escrutada y que todos los votos fueron correctamente incluidos en el escrutinio.
					
					\item[Gestor de tareas:] Utilizando la librería celery y kombu, Helios implementa un gestor de tareas basado en una cola. En el sistema se definen varias tareas que, cuando toca llevarlas a cabo, en vez de encargarse de realizarlas de forma síncrona, las incluye en una cola y sigue con el flujo de funcionamiento normal. Celery se encarga de consultar esta cola y extraer las tareas que hay que realizar. 
					
					Es el responsable de realizar tareas como la carga de ficheros de votantes del censo, iniciar el escrutinio o el envío masivo de emails a usuarios del sistema, entre otras.
					
					\item[Sistema de emails:] Hay un subsistema encargado del envío de emails a usuarios. Lo utiliza tanto el módulo central como celery para enviar emails avisando de los estados de la elección, envío del trozo correspondiente de la clave privada de la elección a los trustees, etc.
				\end{description}
			
			\todo{Diagrama sistema votación}
				\subsection{Esquema de la base de datos}\label{solucion_servidor_votacion_bd}
		
					En la figura \ref{fig:er.servidor.votacion} se muestra el diagrama entidad-relación del sistema Helios Voting, con las modificaciones realizadas en la implementación del sistema de este PFC.
			
					\begin{figure}[!ht]
						\centering
							\includegraphics[width=\textwidth]{imgs/HeliosER.png}
						\caption{Diagrama ER del Servidor de Votación}
						\label{fig:er.servidor.votacion}
					\end{figure}
			
			
					En el esquema se distinguen tres grupos de entidades:
					\begin{itemize}
		
						\item Las propias del core de Helios, cuyos nombres comienzan por \textit{helios\_}. 
		
						\item Las entidades que utilizan la herramienta Celery (las que comienzan por \textit{djcelery\_}).
		
						\item Las entidades que utiliza la herramienta Kombu (las que comienzan por \textit{djkombu\_}).
		
					\end{itemize}
			
					Con respecto al primer grupo, las que forman la capa de negocio del sistema Helios, se observa un diseño bastante simple, aunque adecuado para las necesidades del sistema:
		
		
		
					\begin{description}
			
						\item [helios\_election] Es la tabla que almacena las diferentes elecciones que crean los administradores.
			
						
			
						\item [helios\_auditedballot] En esta tabla se almacenan los votos que los votantes deciden verificar y publicar en el tablón para que puedan ser posteriormente auditados.
			
						
			
						\item [helios\_electionlog] Esta entidad registra los eventos que suceden en torno a una elección, ya sea su creación, congelamiento de la papeleta, apertura de la urna, escrutinio, etc.
			
						
			
						\item [helios\_trustee] Es la entidad que recoge la información de los usuarios que actúan como trustees de la elección. Entre la información de estos que se registra se incluyen las claves públicas que se almacena automáticamente al dar de alta a un trustee. También la clave secreta, que el trustee habrá de subir al servidor una vez se requiera para poder realizar el escrutinio.
			
						
			
						\item [helios\_voterfile] Esta entidad almacena los ficheros de votantes que el administrador sube al servidor desde la interfaz web del sistema. Desde estos ficheros se carga el listado de votantes.
			
						
			
						\item [helios\_user] En esta tabla se almacenan los usuarios / votantes del sistema, relacionados cada uno con las elecciones a las que tienen derecho a voto.
			
						
			
						\item [helios\_auth\_user] Para cada elección, esta tabla asocia usuarios del sistema (con derecho a voto o sin él) con las capacidades de administración.
			
						
			
					\end{description}
					
			\subsection{Estructura}
				El desarrollo del sistema de votación distribuye el código del sistema en una serie de módulos:
				
				\begin{description}
					\item [Core]\hfill \
						Dentro del paquete \textit{helios} se encuentra el código fuente que implementa el núcleo del sistema de votación.
						
						Sigue el protocolo de un proyecto Django sobre el patrón MVC. Contiene las vistas, el modelo y el controlador que necesita para su funcionamiento.
						
						En el fichero \textit{urls.py} se definen los \textit{endpoints} expuestos para la interacción con el sistema. Este fichero establece el punto de comienzo de la \gls{API} \gls{REST} que proporciona el sistema, indicando dónde deben ser realizadas las llamadas HTTP para inicio de procesos y obtención de resultados.
						
						Este fichero funciona como un enrutador. Dirige la llamada a un endpoint hacia la vista que va a tratar esta llamada.
						
						Estas vistas se encuentran agrupadas en el sistema en el módulo contenido en el fichero \textit{views.py}.
						
						Dentro del fichero \textit{models.py} es donde se gestiona el modelo de datos.
						
						Estas son las clases que se definen en este módulo:
						\begin{description}
							\item [Election]
								Clase que gestiona las elecciones que pueden ser creadas en el sistema.

							\item [ElectionLog]
								Clase para gestión de los logs del sistema.
								
							\item [VoterFile]
								Clase diseñada para almacenar los ficheros de votantes utilizados para la carga del censo.
								
							\item [Voter]
								Clase que define los votantes.
								
							\item [CastVote]
								Clase necesaria para almacenar los votos emitidos por los votantes.
								
							\item [AuditedBallot]
								Clase que recoge los votos que han sido auditados.
								
							\item [Trustee]
								Clase que expone los Trustees del sistema.
								
						\end{description}
						
						Se observa que no es un mapeo exacto del modelo Entidad-Relación visto en \ref{solucion_servidor_votacion_bd}. Define las clases principales que interactúan para llevar a cabo la elección.
						
					\item [Autenticación]\hfill \
						El sistema de votación posee un módulo de autenticación propio que es el que gestiona las identidades y permisos de un usuario o votante frente al sistema. Este subsistema recoge la identificación del votante, sea cual sea el medio por el que se haya \textit{logado} el usuario.
						
						En el caso del login por DNIe, este subsistema es el que maneja la comunicación con el Sistema de Autenticación (\ref{arquitectura_servidorAutenticacion}).
						
						Por tanto, bajo la carpeta \textit{helios\_auth} se encuentra el módulo de autenticación del sistema de voto.
						
						Aún siendo un subsistema, sigue también el patrón \gls{MVC} de Django. Contiene los ficheros \textit{urls.py}, \textit{views.py} y \textit{models.py}, tan característicos de este patrón en este framework.
						
						Lo más peculiar de este subsistema es que contiene adaptadores par los diferentes sistemas de login que expone. Dentro de la carpeta \textit{auth\_system} implementa una serie de módulos que gestionan estos diferentes métodos de login.
						
						Por defecto, Helios ha implementado ya los siguientes módulos para permitir la identificación federada:
						\begin{itemize}
							\item Facebook $\Leftarrow$ helios\_auth/facebook.py
							\item CAS $\Leftarrow$ helios\_auth/cas.py
							\item Clever.com $\Leftarrow$ helios\_auth/clever.py
							\item Google $\Leftarrow$ helios\_auth/google.py
							\item LinkedIn $\Leftarrow$ helios\_auth/linkedin.py
							\item Twitter $\Leftarrow$ helios\_auth/twitter.py
							\item Yahoo!	 $\Leftarrow$ helios\_auth/yahoo.py
						\end{itemize}

						Además, incluye un módulo \textit{password.py} utilizado para la identificación de usuario por medio del par \{usuario, contraseña\}.
						
						Para este \gls{PFC} ha sido necesario, pues, la implementación de un módulo nuevo para gestionar la identificación a través del \gls{DNIe}.
						
						Este módulo es \textit{dnie.py}.
						
						Define una clase \textbf{DNIe} con una serie de miembros que almacenan la información del usuario recibida desde el Sistema de Autenticación, del certificado digital de autenticación del \gls{DNIe}.
						
						\begin{lstlisting}[language=Python]
  class DNIe:
      def __init__(self, commonName, givenName, surname, serialNumber, c):
          self.commonName = commonName
          self.givenName = givenName
          self.surname = surname
          self.serialNumber = serialNumber
          self.c = c
						\end{lstlisting}
						
						\todo{POR AQUí}
						
						
					\item [Cabina de votación]\hfill \
						En la carpeta \textit{helios\_booth} se encuentra el componente de la Cabina digital de Voto.
						
						Es un módulo autocontenido cuya funcionalidad se desarrolla en tan sólo un elemento HTML, apoyado en código Javascript para controlar la interacción con el usuario, el cifrado de los votos y el envío del voto al Sistema de Votación en servidor. La lógica de este módulo se ejecuta en cliente, por eso es importante la comunicación final con el servidor.
						
						Su estructura y funcionamiento se explica en \ref{esquemaVotacion_votacion}.
						
						
					\item [Verificador de voto]\hfill \
						El verificador de voto es una herramienta para que un votante u observador pueda verificar que el sistema cifra y descifra correctamente un voto.
						
						
					\item [Tests selenium]\hfill \
						
						
					\item [Elementos estáticos]\hfill \
						Esta carpeta contiene los ficheros estáticos necesarios para la interfaz web, incluyendo HTML, Javascript y hojas de estilo CSS.
						
				\end{description}

				
					
		\section{Cliente Android}\label{arquitectura_cliente}
			El cliente del sistema se apoya en el navegador web que utilice el usuario para interactuar con el sistema, principalmente contra el subsistema de votación, pero también contra el de autenticación.
			
			Ambos sistemas son aplicaciones web, por lo que esta interacción se realiza a través de páginas web que permiten al usuario comunicarse con los servidores.
			
			Como cualquier aplicación web, ambos sistemas sirven sus propias páginas o APIs para que puedan ser renderizadas por el navegador web del usuario y que éste pueda realizar las acciones oportunas.
			
			No obstante, debido a la necesidad de uso de certificados digitales de cliente como herramienta para la identificación digital, se hace necesario incluir una capa de comunicación entre el navegador y estos certificados.
			
			En el caso de la navegación desde un \gls{PC}, esta capa intermedia son los drivers del \gls{DNIe}, que gestiona el propio Sistema Operativo, con los que, a través de un lector del chip de contacto, accede a los certificados y los presenta, a través de su Almacén de Certificados, al navegador para que los tenga accesibles.
			
			Esto no es posible, sin embargo, en dispositivos Android. No existen drivers para acceder a los certificados del \gls{DNIe} 3.0 por NFC desde un dispositivo Android. No es posible, por tanto que un navegador web en este Sistema Operativo tenga acceso a los certificados como ocurre en un navegador de escritorio.
			
			La idea original era acceder al sistema de votación con un login con los certificados digitales directamente contra el servidor de votación, que sería el que estaría protegido y esperaría estos certificados de cliente.
			
			En el capítulo \ref{analisis_identificacion} se explica la evolución experimentada para la solución de este problema, pues no era posible llevar a cabo la primera idea y hubo que estudiar diversas opciones hasta encontrar con la que finalmente se implementó. Esta consiste en la implementación de una app Android que haga de intermediaria entre el navegador web del dispositivo y, por un lado, la lectura por \gls{NFC} del certificado de autenticación del \gls{DNIe} 3.0 y, por otro lado, con su uso contra el Sistema de Autenticación, para, al final del proceso, dirigir al usuario al propio navegador web con el acceso al Sistema de Votación ya validado.
			
			\begin{figure}[!ht]
				\centering
			 	\includegraphics[width=0.80\textwidth]{imgs/arquitecturaAndroidApp.jpg}
			  	\caption{Arquitectura lógica de la App sobre DNIeDroid\cite{dnieAutenticacion:1.0}}
			  	\label{fig:arquitecturaAppDnieDroid}
			\end{figure}
		
			\subsection{Código fuente}\label{solucion_app_codigofuente}
				Obviamente, el código fuente de la app ha debido ser modificado ya que la funcionalidad que se busca que tenga la aplicación no es la misma que la que ofrece la original.
		
				En la app original, al entrar se nos ofrece un menú radial con diferentes opciones. Esto no ocurre en la versión de este proyecto. La app en nuestro caso está pensada para realizar tan sólo un trabajo, realizar la identificación y autenticación de usuario contra un servidor oAuth y transmitir al sistema de votación la aceptación o revocación de acceso del mismo contra el sistema.
		
				Por ello, la app va a carecer de un menú inicial, ya que no es necesario.
		
				Una vez se abra la app, ya sea desde el menú del dispositivo o desde el botón de login de la página inicial de la web del sistema de votación, aparecerá el menú de selección del CAN del DNIe que queremos utilizar, o, si es la primera vez que cierto usuario utiliza la app, la posibilidad de añadir un nuevo DNIe con su CAN correspondiente.
				
				\todo{Me he traído esto del código fuente aquí. Hay que cambiarle el nombre e integrarlo con la subsection siguiente}
			
			\subsection{App Android de Autenticación}\label{solucion_appAndroidAutenticacion}
					Ya se ha explicado que para realizar el acceso al sistema de voto desde dispositivos móviles, se ha optado por modificar una de las apps de ejemplo publicadas por la Policía española.
					
					La app original mostraba un ejemplo de funcionamiento en el que se accedía a varias webs que necesitaban acceso con identificación por DNIe. Las modificaciones que se han realizado a esta app han consistido en:
					\begin{itemize}
						\item Eliminar el menú inicial con el que se podía elegir el servicio al que se pretendía acceder.
						\item La app ahora sólo tiene una funcionalidad, conectarse contra el servidor de autenticación de nuestro sistema de votación.
						\item Para ello, se ha modificado el software cambiando el flujo de llamadas. Originalmente sólo se hacía una llamada a una web para obtener información. Para cumplir con el protocolo oAuth, se ha incrementado el número de llamadas HTTPS de la app, con una mayor comunicación bidireccional entre el servicio y el dispositivo.
						\item La app embebe keystore con los certificados de servidor y el raíz de la Policía para cada uno de los servicios que utiliza. Se han eliminado y se ha incorporado una keystore con los certificados del servidor de autenticación y el de la AC raíz de la Policía.
						\item La app posee una lista de servidores en los que confía. En esta lista se incluyen los hashes de los certificados de servidor de los servicios que consulta. Se han eliminado los elementos de esta lista y se ha añadido el hash del certificado del servidor de autenticación, que es contra el que ahora se va a comunicar la app.
						\item En la app original, se realiza una llamada HTTPS, se obtiene la información y se muestra en una página estática dentro de un WebView. Los WebViews en Android no soportan navegación manteniendo certificado de cliente, por lo que no es útil para la nueva funcionalidad de nuestra app. Por ello, se ha eliminado esta forma de mostrar información. Ahora se realizan las comunicaciones del flujo oAuth y cuando el usuario ha sido identificado y autenticado, se redirige a la web del sistema de voto por medio de un navegador externo a la app.
					\end{itemize}
					
					La comunicación puede comenzar de dos formas:
					\begin{enumerate}
						\item El usuario entra con un navegador móvil en la web de la elección (figura \ref{fig:login.android.navegador}). Esta le muestra un link para realizar el login seguro a la misma. El sistema de voto identifica con Javascript que el usuario accede desde un dispositivo Android, con lo que modifica el link para que se ejecute un intent, la intención de abrir una app en el dispositivo, en lugar de redirigirse a una web.
						Este link modificado se corresponde con 
\begin{lstlisting}[language=XML]
  intent://scan/#Intent;scheme=dnie;package=com.dnieadmin;end
\end{lstlisting}
						
						En este enlace, \textit{scheme=dnie} y \textit{package=com.dnieadmin} son valores definidos en el AndroidManifest.xml del proyecto. Al utilizar el protocolo \textit{intent://} se indica al dispositivo que se está \textit{intentando} utilizar una aplicación.
						
						 Si la app se encuentra instalada, se abrirá. En caso contrario, se dirige al usuario a la Play Store de Google para que se descargue la app.
						\begin{figure}[!h]
							\centering
								\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_020.png}}
							\caption{Página de inicio en navegador de dispositivo Android.}
							\label{fig:login.android.navegador}
						\end{figure}
						
						\item Directamente, el usuario entra en la app desde el menú de aplicaciones (figura \ref{fig:login.android.menu}) del Launcher del Sistema Operativo.
						
						\begin{figure}[h!]
							\centering
								\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_010.png}}
							\caption{Menú de aplicaciones de dispositivo Android}
							\label{fig:login.android.menu}
						\end{figure}
					
					\end{enumerate}
					
					
					En este momento, cualquiera que sea el camino que se ha seguido, el usuario entra en la app. Con respecto a la app original, se ha eliminado el menú principal y todas las funcionalidades que aportaba. Directamente, se muestra la pantalla de introducción o selección del \gls{CAN} (figura \ref{fig:login.android.seleccionCANvacio}). El \gls{CAN} es un identificador de 6 dígitos que aparece en el anverso del documento físico del \gls{DNIe}. Se utiliza para establecer un canal cifrado \gls{PACE} entre el documento y el dispositivo.
					
					\begin{figure}[!ht]
						\centering
							\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_030.png}}
						\caption{App Autenticación Android: Selección del CAN cuando no hay ningún documento guardado previamente.}
						\label{fig:login.android.seleccionCANvacio}
					\end{figure}
					
					Este canal \gls{PACE} es obligatorio a la hora de establecer una conexión inalámbrica cifrada, pero no sustituye al \gls{PIN} en ningún caso, igual que no da permiso de uso de las claves de autenticación y/o firma del ciudadano. Es una herramienta más de seguridad para evitar que un tercero pueda leer información del DNIe sin conocimiento del ciudadano dueño del documento.
					
					\begin{figure}[!ht]
						\centering
							\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_035.png}}
						\caption{App Autenticación Android: Pantalla para introducir el CAN.}
						\label{fig:login.android.introducirCAN}
					\end{figure}
					
					Una vez introducido el \gls{CAN} por primera vez, ya no será necesario volver a hacerlo, ya que se almacena en el sistema y puede seleccionarse el apropiado cada vez que el usuario hace uso de la aplicación. Al igual que se pueden guardar más documentos, es posible eliminar el \gls{CAN} de documentos ya introducidos. (figura \ref{fig:login.android.seleccionCAN})
					
					\begin{figure}[!ht]
						\centering
							\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_040.png}}
						\caption{App Autenticación Android: Selección del CAN.}
						\label{fig:login.android.seleccionCAN}
					\end{figure}
					
					En caso de intentar una lectura de la información de un \gls{DNIe} introduciendo un \gls{CAN} incorrecto se produciría un error al establecer el canal \gls{PACE} y no sería posible la comunicación entre documento y dispositivo (figura \ref{fig:login.android.seleccionCANvacio}).
					
					\begin{figure}[!ht]
						\centering
							\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_036.png}}
						\caption{App Autenticación Android: Error al introducir un CAN incorrecto.}
						\label{fig:login.android.seleccionCANvacio}
					\end{figure}
					
					Cuando se ha indicado el \gls{CAN} correcto del documento que se va a utilizar para logarse en el sistema, la aplicación solicita al usuario que acerque su documento físico al dispositivo para que este pueda acceder a los certificados (figura \ref{fig:login.android.aproximeDNIe}).
					
					\begin{figure}[!ht]
						\centering
							\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_050.png}}
						\caption{App Autenticación Android: Esperando que se aproxime el DNIe 3.0.}
						\label{fig:login.android.aproximeDNIe}
					\end{figure}
					
					La comunicación entre documento y dispositivo se realiza mediante \gls{NFC} (\ref{estadoNFC}). Según el documento \cite{dnieAutenticacion:1.0}, los desarrolladores de la app de ejemplo indican que \textit{''por motivos de hardware y de seguridad, la distancia máxima soportada por NFC es, dependiendo del dispositivo, de alrededor de un centímetro''}. De todos modos, es una comunicación ciertamente sensible, que se ve afectada por la distancia y el movimiento, necesitando para un correcto funcionamiento cercanía y una notable estabilidad.
					
					
					Una vez estén cerca documento y dispositivo, se detectarán y establecerán la comunicación cifrada entre ambos (figura \ref{fig:login.android.cargandoCertificados}), a través de la cual podrán intercambiarse tanto comandos como respuestas a estos, accediendo a la información alojada en los certificados y permitiendo a estos firmar información presentada por el dispositivo (aunque en nuestra app no hará falta utilizar el certificado de firma digital).
					
					
					\begin{figure}[!ht]
						\centering
							\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_060.png}}
						\caption{App Autenticación Android: Cargando certificados.}
						\label{fig:login.android.cargandoCertificados}
					\end{figure}
					
					
					Para poder llegar a utilizar los certificados, no obstante, primero se solicitará el \gls{PIN} al usuario (figura \ref{fig:login.android.DNIe.PIN}), con el cual se autentica al mismo contra el DNIe y se le conceden permiso de acceso a las claves. A partir de este momento, la comunicación entre documento y dispositivo va cifrada y se pueden acceder a los certificados.
					
					\begin{figure}[!ht]
						\begin{subfigure}{.5\textwidth}
							\centering
								\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_070.png}}
							\label{fig:login.android.introducirPIN}
						\end{subfigure}
						\begin{subfigure}{.5\textwidth}
							\centering
								\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_080.png}}
							\label{fig:login.android.PINintroducido}
						\end{subfigure}
						\caption{App Autenticación Android: Introducción del PIN del DNIe 3.0}
						\label{fig:login.android.DNIe.PIN}
					\end{figure}
					
					Es en este momento cuando la app utiliza el certificado de autenticación del DNIe realizar una petición HTTPS/TLS contra el servidor de autenticación del sistema de voto. Cada una de las llamadas que le exige el protocolo de comunicación oAuth2 se realizará de forma segura, con los certificados del servidor y el de autenticación del documento (figuras \ref{fig:login.android.lanzandoConexion} y \ref{fig:login.android.recepcionCodigooAuth}). 
					
					\begin{figure}[!ht]
						\centering
							\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_090.png}}
						\caption{App Autenticación Android: Lanzando conexión segura con los certificados.}
						\label{fig:login.android.lanzandoConexion}
					\end{figure}
					
					\begin{figure}[!ht]
						\centering
							\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_100.png}}
						\caption{App Autenticación Android: Recepción de código oAuth.}
						\label{fig:login.android.recepcionCodigooAuth}
					\end{figure}
					
					Para poder establecer un canal seguro contra el servidor de autenticación, es necesario, según la implementación de la app original de ejemplo, que el certificado del servidor y la AC raíz vayan embebidos en el código de la app. Así mismo, es necesario que se incluya el hash del mismo para que el objeto DroidHTTPClient que establece la conexión al servidor sea capaz de establecer este camino seguro.
					
					Esta keystore con los dos certificados se debe incluir en el proyecto Android con un formato BKS, lo cual se consigue realizando los pasos expuestos en el anexo \ref{App:exportarCertsAppAndroid}.
					
					Una vez obtenido el fichero keystore que contiene los dos certificados, ha de colocarse en la carpeta del proyecto:
					
\begin{lstlisting}
  clienteAndroidDNIeoAuth2/app/src/main/res/raw
\end{lstlisting}
					
					Para añadir el hash del certificado del servidor habrá que editar también el fichero:
					
\small\begin{lstlisting}
  clienteAndroidDNIeoAuth2/app/src/main/res/values/trusted_hosts.xml
\end{lstlisting}
					
					Este hash se obtiene en el servidor con el comando que se indica igualmente en el anexo \ref{App:exportarCertsAppAndroid}.
					
					Así, el fichero que indica qué servidores son confiables y que utiliza la app para poder establecer una conexión segura con el servidor quedaría parecido a este:
					
					
\footnotesize\begin{lstlisting}[language=XML]
  <resources xmlns:android="http://schemas.android.com/apk/res/android">
    <array name="trusted_hosts">
      <!-- En el servidor: openssl x509 -fingerprint -noout -in server.crt -->
      <item>D5E6E3759023DE9B881399DC034E8FE1AE7D9D87</item>
    </array>
  </resources>
\end{lstlisting}
					
					El servidor de autenticación establece un canal seguro con su certificado (en el prototipo será autofirmado) pero valida el certificado de autenticación con el certificado AC Raíz de la Policía que posee y que se ha configurado para ser utilizado. Por esta razón aparece un error en el navegador cuando se entra por primera vez a la web (figura \ref{fig:login.android.certAutofirmado}). Avisa al usuario de que no encuentra en su almacén de certificados uno que sea confiable con el servidor. En nuestro caso, para el prototipo, bastará con hacer click en \textit{CANCELAR} ya que no vamos a instalar certificados adicionales. En caso de implementar el sistema en producción, será necesario obtener e instalar en el servidor un certificado confiable, emitido por una autoridad de confianza.
					
								
					
					\begin{figure}[!ht]
						\centering
							\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_105.png}}
						\caption{App Autenticación Android: Los certificados autofirmados no son seguros, pero la comunicación va cifrada de todos modos.}
						\label{fig:login.android.certAutofirmado}
					\end{figure}
					
					Una vez asumimos el certificado autofirmado, por fin accedemos a la web del sistema de voto logados con la información contenida en el certificado de autenticación de nuestro DNIe 3.0 (figura \ref{fig:login.android.logado}).
					
					\begin{figure}[!ht]
						\begin{subfigure}{.5\textwidth}
							\centering
								\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_110.png}}
							\label{fig:login.android.logado01}
						\end{subfigure}
						\begin{subfigure}{.5\textwidth}
							\centering
								\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_120.png}}
							\label{fig:login.android.logado02}
						\end{subfigure}
						\caption{App Autenticación Android: Acceso al sistema de voto con login con el DNIe.}
						\label{fig:login.android.logado}
					\end{figure}


		\begin{figure}[!ht]
			\centering
				\includegraphics[width=.95\textwidth]{imgs/arquitecturaSistema.jpg}
			\caption{Arquitectura del sistema}
			\label{fig:arquitectura.sistema}
		\end{figure}	
					

		
		\section{Topología de red}\label{solucion_topologiaRed}
				\todo[inline]{Para esto sí que necesito ayuda, por el tema de Firewalls y esas cosas.}
				
				De cara a la topología de la red del sistema, se ha diseñado la integración para abordar tres configuraciones diferentes dependiendo de las necesidades de la elección:
				
				\begin{enumerate}
					\item \textbf{Servidor de autenticación y Servidor de votación en la misma red. Acceso de los votantes desde Internet.} Figura \ref{fig:topologiaRed_servidoresMismaRed}
						
						Esta topología requiere port forwarding del router que comunica la red de los dos servidores con Internet para que, a través del mismo endpoint, los dispositivos se puedan conectar con los servicios de ambos servidores.
						
						Las consultas OCSP para validación del DNIe se realizan a través de Internet.
						\newline
						
						
						\begin{figure}[htbp]
							\centering
								\includegraphics[width=0.30\textwidth]{imgs/topologiaRed01.jpg}
							\caption{Topología de la red con los servidores compartiendo red.}
							\label{fig:topologiaRed_servidoresMismaRed}
						\end{figure}
						
						
						
					\item \textbf{Servidor de autenticación y Servidor de Votación en redes diferentes. Acceso de los votantes desde Internet.} Figura \ref{fig:topologiaRed_servidoresDistintaRed}
						
						Esta topología no requiere port forwarding, pues cada servidor tiene su propio acceso a/por Internet. Los dispositivos accederían directamente a la IP/URL de cada servidor y utilizarían sus diferentes servicios utilizando el puerto correspondiente.
						
						Las consultas OCSP para validación del DNIe se realizan a través de Internet.
						\newline
						
						
						
						\begin{figure}[htbp]
							\centering
								\includegraphics[width=0.30\textwidth]{imgs/topologiaRed02.jpg}
							\caption{Topología de la red con los servidores en redes diferentes.}
							\label{fig:topologiaRed_servidoresDistintaRed}
						\end{figure}
						
						
						
					\item \textbf{Tanto el Servidor de autenticación, como el Servidor de Votación y los dispositivos se comunican por la misma red, sin necesitar acceder a través de Internet.} Figura \ref{fig:topologiaRed_intranet}
						
						Haría falta un acceso a Internet para poder realizar consultas OCSP de validación del DNIe.
						
						Esta topología de red interna no cumple con los requisitos de voto e identificación remotos a través de Internet definidos en \ref{requisitosFuncionales}, pero es una buena solución para elecciones internas o para la presentación de un prototipo.
						\newline
						
						
						\begin{figure}[htbp]
							\centering
								\includegraphics[width=0.30\textwidth]{imgs/topologiaRed03.jpg}
							\caption{Topología de la red con los servidores y los dispositivos en red privada.}
							\label{fig:topologiaRed_intranet}
						\end{figure}
				\end{enumerate}
				
		
			\section{Esquema de votación}\label{disenhoEsquemaVoto}
				\subsection{Registro}
					La fase de registro de votantes en el sistema no será interactivo en cuanto a que no es el propio votante el que debe inscribirse para poder votar en las elecciones, sino que es la Autoridad Electoral quien lo registra en el censo. En esta fase, pues, se trata de establecer el censo de votantes que tienen autoridad para votar en el proceso electoral.
					
					Como se advierte en el análisis se ha tomado en consideración que sean los administradores del sistema quienes tengan responsabilidad sobre el tratamiento del censo, por lo que se ha de cargar en el sistema y éste es el que lo va a tratar.
					
					El censo ha de cargarse en dos servicios del sistema, tanto en el servidor de autenticación como en el sistema de votación.
					
					El censo del subsistema de autenticación se utilizará para llevar el control de los votantes que tienen derecho de acceso al sistema, por lo que a los votantes se les pueden añadir otros usuarios necesarios para llevar a término la votación, como pueden ser administradores o auditores, aunque estos no tengan derecho de voto. Así se conformaría la base de usuarios activos del sistema.
					
					En el subsistema de voto también se vuelca el censo para cada uno de los diferentes procesos de voto que conformen la elección.
					
					El procedimiento a seguir consistirá en que la Autoridad Organizadora del Proceso Electoral, la Universidad, proveerá una lista del censo a los administradores del sistema. El administrador utilizará la función de carga de votantes con la lista proporcionada para realizar la carga inicial de votantes para cada una de las subelecciones que se configuren.
					
					La lista proporcionada por la Universidad debe contener la siguiente información de cada uno de los votantes:
						\begin{itemize}
							\item Nombre y apellidos
							\item DNI
							\item Clase / grupo de votantes
							\item E-mail
						\end{itemize}
						
					La carga de los votantes a través de su aplicación se realiza subiendo un fichero csv con la información requerida. Este fichero se pone a disposición de la cola de procesos, la cual, llegado el momento volcará cada uno de los registros en la base de datos del sistema de votación.
					
					\notasDuda{Falta definir el proceso de carga de votantes para el servicio de autenticación.}
					
				\subsection{Identificación / Autenticación}
					El servicio de identificación es un subsistema clave en el proceso electoral. En él recae parte de la responsabilidad de la robustez del sistema, en cuanto a que debe asegurar varios de los requisitos básicos que definen el voto electrónico en concreto:
					
		\notasInfo[inline]{Esto es así según los requisitos de Fujioka, si se utilizan los de la UNEX, se puede modificar.}
		\begin{description}
			\item[Solidez:] Debe asegurar que un votante deshonesto no tenga capacidad de acceder al sistema e interrumpir la votación. Es decir, que sólo debe dar acceso a los votantes que realmente deben ingresar al sistema de votación.
			
			\item[Elegibilidad:] Este requisito implica que el sistema debe controlar que ningún votante que no tenga permitido el voto pueda votar. Aunque es el proceso de votación el que debe controlar esta circunstancia cuando un usuario trata de emitir un voto, el sistema de votación, de forma análoga al requisito anterior, también debe proteger el sistema evitando el acceso a aquellos que, directamente, no tengan permisos para votar.
			
			\item[Sin duplicados:] El sistema debe evitar que un votante duplique o reemplace el voto de otro. Igualmente, aunque es el sistema de votación el que debe tener mecanismos que controlen esta situación, la primera barrera debe ser la servicio de autenticación del votante.
			
		\end{description}

					
			 El sistema de identificación del votante se apoya en el protocolo oAuth2.

			Como ya se ha comentado, el sistema de identificación/autenticación federada que se va a utilizar se basa en un proyecto publicado como software libre por el desarrollador Richard Knop con nombre django-oauth2-server.
			
			Este servidor está escrito en Python y se ha desarrollado sobre el framework Django, el mismo sobre el que está desarrollado el propio sistema de votación, Helios Voting.
			
			El sistema, tal como está desarrollado no se adecua a las necesidades del proyecto, pues no soporta certificados digitales.
			
			
			El primer paso para la implementación del servidor consiste en configurar el framework Django para que se apoye en un servidor web externo. Para este proyecto se ha utilizado el servidor web Apache.
			
			Es necesario instalar dos módulos específicos:
			
			\begin{description}[font=$\bullet$\scshape\bfseries]
				\item[mod\_wsgi]: Módulo que permite que una aplicación basada en Django corra sobre un servidor web externo, como Apache.
				\item[mod\_ssl]: Módulo que permite a ciertos servidores web utilizar certificados digitales como forma de autenticación. En el caso de nuestro proyecto, servirán tanto para establecer los canales SSL/TLS como para incluir el certificado digital de autenticación del DNIe en el canal seguro, recuperar la información de usuario del certificado y pasarla al código del servidor.
			\end{description}
					
					
					\begin{figure}[!htbp]
						\centering
							\includegraphics[width=.95\textwidth]{imgs/flujoOAuth20.jpg}
						\caption{Flujo oAuth para servicio de autenticación}
						\label{fig:flujo.oauth}
					\end{figure}
					
					\ref{fig:flujo.oauth}
					\begin{enumerate}
						\item La app del DNIe obtiene las credenciales del chip de identificación del documento por \gls{NFC}.
						\item La app realiza una petición GET a la web del Sistema de Autenticación.
						\item El Sistema de Autenticación devuelve un formulario de aceptación con la información de los \textit{scopes} de autorización.
						\item La app Android realiza una petición POST con los \textit{scopes} aceptados por el usuario, dando aquí su conformidad a que la aplicación web de votación tenga acceso a información sobre el usuario.
						\item El Sistema de Autenticación consulta la Base de Datos de censo de votantes y usuarios y, si permite el acceso al usuario, devuelve un \textit{access code}.
						\item La app del DNIe lanza un \textit{intent} de Android para abrir el navegador web por defecto del dispositivo en la página de inicio del Sistema de Votación, pasándole además el \textit{access code}. Aquí el entorno del dispositivo termina en la app y pasa al navegador web.
						\item Desde el navegador, se lanza una petición de acceso al Sistema de Votación con el \textit{access code} y una url de \textit{callback} como parámetros.
						\item El Sistema de Votación realiza una petición a la url del Sistema de Autenticación que va en el \textit{callback} (/api/token) con el \textit{access code} como parámetro.
						\item El Sistema de Autenticación genera y devuelve un \textit{token} al Sistema de Votación.
						\item Con el \textit{token} recibido, el Sistema de Autenticación asegura la identidad del usuario y lo utiliza para poder información al Sistema de Autenticación. Por ejemplo, con una petición al \textit{endpoint} /web/me del Sistema de Autenticación...
						\item Éste le devuelve información acerca del usuario.
						\item Una vez que el sistema ha recibido el \textit{token} y la información de usuario del votante, considera probada la identidad digital de este, por lo que se le considera \textit{logado} en el sistema y se le permite la interacción con éste.
					\end{enumerate}

					
				\subsection{Definición de la papeleta}\label{solucion_definicionPapeleta}
					El principal cambio que se ha implementado en la tarea de definición de las opciones de la papeleta ha sido el de añadir automáticamente la opción del voto en blanco a la papeleta.
					
					Ahora, cada vez que un administrador cree una consulta en una papeleta, junto con las opciones que defina, automáticamente se adjuntará la opción del voto en blanco.
					
					Esta modificación trata de satisfacer el requisito \ref{reqEspecificos_blancos} definido entre los requisitos específicos (\ref{requisitosEspecificos}).
					
					
				\subsection{Votación}\label{esquemaVotacion_votacion}
					Para la votación, el sistema implementa una \textit{Cabina de Votación} lógica. Es un módulo que se ejecuta en el cliente y no en el servidor.
					
					El sistema se encarga de esta forma de proteger el secreto del voto y la privacidad del votante. El voto se cifra en el navegador del cliente antes de ser enviado al servidor.
					
					El sistema lo recibe encriptado y lo guarda así en la base de datos (urna digital).
					
					En la totalización (\ref{solucion_totalizacion}), el sistema utilizará técnicas criptográficas avanzadas para combinar todos los votos cifrados y descifrar simplemente la suma de ellos. En ningún momento del proceso electoral el sistema maneja un solo voto descifrado de forma individual.
					
					El módulo de votación es un fichero HTML, vote.html, orquestado por código Javascript, escrito dentro del mismo fichero entre etiquetas <script></script>.
					
					\begin{figure}[!ht]
						\centering
							\includegraphics[width=.95\textwidth]{imgs/cabinaVotacion01.jpg}
						\caption{Esquema de la Cabina de Votación}
						\label{fig:esquema.cabina.votacionh}
					\end{figure}
					
					Además, incluye varias librerías Javascript externas, como son:
					\begin{description}[font=$\bullet$\ \ ]
						\item [jQuery] Librería que contiene código que extiende la funcionalidad de Javascript realizando más intuitiva la gestión del DOM. Incluye código para gestionar plantillas y estilo para la web. Es una librería muy utilizada en el mundo del desarrollo Web.
						\item [bigint.js] Implementación de un wrapper para la clase java.math.BigInteger. Necesaria para la gestión de los números grandes utilizados para los diferentes cifrados, tanto como generadores, elementos, semillas o retos.
						\item [random.js] Generador de números aleatorios.
						\item [elgamal.js] Implementación en Javascript del algoritmo de cifrado del ElGamal.
						\item [sha1.js, sha2.js] Implementación en Javascript de los algoritmos de cifrado SHA-1 y SHA-2.
					\end{description}
					
					
					Durante todo el proceso de votación, aunque éste se divide en tres pasos, el votante se encuentra en la misma página vote.html. La orquestación entre una fase y la siguiente se gestiona a través de código Javascript.
					
					\begin{figure}[!ht]
						\centering
							\includegraphics[width=.95\textwidth]{imgs/diagramaEstadosVotacion01.jpg}
						\caption{Diagrama de estados del proceso de votación}
						\label{fig:diagrama.estados.cabina.votacion}
					\end{figure}
					
					\begin{description}
						\item[Inicio]\hfill \
						
							Se muestra al votante un explicación del proceso que va a realizar para votar, con una enumeración de las fases que proceden.
							
							Se incluye un botón para comenzar a votar.
							\newline

						\item[Paso 1. Selección de candidatos] \hfill \
						
							Se muestra al votante los candidatos para cada una de las preguntas que la elección le permite votar.
							
							Dependiendo de la configuración de la elección y de cada una de las preguntas, el votante podrá no elegir ningún candidato, elegir sólo 1, un rango de candidatos, abstenerse o votar en blanco.
							
							En la zona inferior se le indica al votante cuál es la Huella Digital de la Elección en la que está votando. Esta huella es el hash del JSON que define la propia elección. Por tanto, la huella depende de la lista de votantes censados o registrados. Así, en caso de modificarse el censo una vez que se ha abierto la votación, aquí hay una herramienta para detectarlo, ya que esta huella no se correspondería con la que se genera una vez modificada la elección.
							
							Tras seleccionar los candidatos, el votante puede pulsar el botón de continuar.
							\newline
							
							

						\item[Cifrado del voto] \hfill \
						
							Entre el paso 1, donde se eligen los candidatos, y el paso 2, donde se revisa y audita el voto, el navegador cifra la papeleta.
							
							A continuación se muestra el esquema de un voto cifrado:
\begin{lstlisting}[basicstyle=\tiny\ttfamily]
{
 "answers": [
  {
   "choices": [
    {
     "alpha": "11821738026205240772968255127044802517047(...)",
     "beta": "956239812618638278768915552438226298243021(...)"
    },
    {
     "alpha": "89930541535253719726930300864046225791303(...)",
     "beta": "280059812585494032480202717650783375169670(...)"
    },
    {
     "alpha": "57975502776035240719836621535262618419174(...)",
     "beta": "978382211305766369879688192639985576524767(...)"
    }
   ],
   "individual_proofs": [
    [
     {
      "challenge": "43874538621142379916145492966409289430255985276793233839535144670232793929873",
      "commitment": {
       "A": "14614624460580166084310239809768957161396(...)",
       "B": "12129363808208853658297038681359129740187(...)"
      },
      "response": "35111610374554771924491600617435125565551351678779095565911261872333649419481"
     },
     {
      "challenge": "17455027627200521376398379804435998722483175501173674963493255507426299982582",
      "commitment": {
       "A": "14276144535969498348508852984424238679819(...)",
       "B": "54937556950085798690537717077801057528298(...)"
      },
      "response": "55879767585126448548489172509549767078598169937256353971492493135916950997178"
     }
    ],
    [
     {
      "challenge": "27214371254593561525103755246527245415365098004925989240328291157531952501665",
      "commitment": {
       "A": "33082796917013189624560150325204466774925(...)",
       "B": "12435741661345782068706114279439280143590(...)"
      },
      "response": "10558534534412804489745997990430567976230006025326885338612204248676172306992"
     },
     {
      "challenge": "34115194993749339767440117524333388461738390285322076679882585342267066946683",
      "commitment": {
       "A": "13731698192008366840053574489091548941274(...)",
       "B": "93495042406845358075899133494203376927794(...)"
      },
      "response": "5176763459334639863434268463535510901594167363643527842720657697790809305897"
     }
    ],
    [
     {
      "challenge": "20540246645133510248508772126054804332279131831120275199135559606644095246601",
      "commitment": {
       "A": "10106397188055812737742462645321636338276(...)",
       "B": "37029221908705879439687143590563027454957(...)"
      },
      "response": "7673773933284719536412259876677204164956289948480475588198037430892323898227"
     },
     {
      "challenge": "40789319603209391044035100643943546996234603809846160735535922393763413197438",
      "commitment": {
       "A": "15229611588330633510585960074995900185751(...)",
       "B": "21334632161958188873895465185349941827553(...)"
      },
      "response": "6852566648753632522678906133616629808473941306022210723994794012868737228377"
     }
    ]
   ],
   "overall_proof": [
    {
     "challenge": "1253752696342774217501410594567017563436392503337",
     "commitment": {
      "A": "1179324149342428195002072934744877439171442(...)",
      "B": "8523081220255060312531704762208280291556391(...)"
     },
     "response": "13968935777329836215146425324634396744895179592294679261573217697722622897973"
    }
   ]
  }
 ],
 "election_hash": "gb+MGZVlw8UmBIljELcfzSeYfYEAXj9h+xqcr+eE2W0",
 "election_uuid": "4eadbc3a-bbff-11e6-b149-b827eb1e9722"
}
\end{lstlisting}
							El contenido de un voto completo se puede ver en el anexo \ref{anexo:ejemploVotoJSON}.
							\newline
						\todo[inline]{CAPTURA PANTALLA}
						
						
						\item[Paso 2. Revisar el voto] \hfill \
						
							Entre el Paso 1 y el 2, se realiza el cifrado del voto.
							
							Una vez seleccionados los candidatos, el sistema nos permite realizar una revisión de nuestra elección. Así, se puede modificar el voto volviendo al Paso 1.
							
							En este punto, se genera un código que sirve para realizar el seguimiento del voto si se decide enviar a auditoría.
							
							En este paso, el votante tiene la opción de continuar para emitir su voto, con lo que continuaría al Paso 3, o tiene la opción de descifrar su voto y enviarlo a auditoría.
							\newline

							\todo[inline]{CAPTURA PANTALLA}


						\item[Paso 3. Emitir el voto] \hfill \
						
							Con el voto ya preparado y cifrado, la Cabina de Votación envía el voto cifrado al Servidor de Votación. En este momento el votante todavía tiene la opción de votar o de cancelar el voto. 
							
							Una vez emita su voto, este se guardará cifrado en la base de datos y nunca será descifrado. Se combinará con el resto de votos cifrados y por homomorfismo aditivo lo que se descifrará será la suma de todos los votos cifrados.
							
							Este sistema de voto permite al votante votar tantas veces desee. Sólo se tendrá en cuenta su último voto, quedando los anteriores descartados y fuera del escrutinio. El motivo de este detalle es proteger al votante de un posible escenario de coacción.
							\newline

\todo[inline]{CAPTURA PANTALLA}


						\item[Auditar el voto] \hfill \
						
							El votante tiene la opción de auditar el voto. Una vez su voto ha sido cifrado, puede elegir revelar cómo se ha realizado el cifrado de los candidatos que ha seleccionado. El sistema muestra el JSON en el que se han cifrado las opciones del votante y estas pueden utilizarse en una herramienta externa para verificar este proceso de cifrado.
							
							Este voto, que ha sido expuesto, no se contabilizará en la totalización. El votante debe volver a la Cabina de Votación para que se vuelva a cifrar su voto y pueda votar con un voto no comprometido.
							
							El proceso de evitar que un votante pueda emitir el mismo voto que audita se realiza para dar algo de protección al votante contra la coacción.
							
							Igualmente, el votante tiene la posibilidad de enviar su voto auditado a un tablón de seguimiento de votos (Ballot Tracking Center), donde cualquier votante u observador puede realizar la verificación de ese voto.
							\newline
							
\todo[inline]{CAPTURA PANTALLA}
							
							
						\item[Verificación del voto] \hfill \
					
							La herramienta de verificación del voto permite a un votante u observador verificar que el voto fue preparado y cifrado correctamente.
							
							Requiere como entrada de datos el JSON del voto y la URL de la elección.
							
							El verificador hace uso de pruebas de conocimiento zero para comprobar la validez del voto y de su cifrado. 
							
							Comprueba que la huella de la elección se corresponde con la huella del voto. También comprueba la validez de cada una de las opciones elegidas por el votante.
								
\begin{lstlisting}
  loading election...
  election fingerprint is 4txg7mWSzN8tuZY2l7hvi7HtdbD15fZlRRPBdwZNQMU
  smart ballot tracker is oBeyzSaS2yi0BN+ubTUMzSPNck73+yQxZU2mSNrH/7s
  election fingerprint matches ballot
  Ballot Contents:
  Question #1 - Preguntando : 
  Encryption Verified
  Proofs ok.


  SUCCESSFUL VERIFICATION, DONE!	
\end{lstlisting}
								En el anexo \ref{anexo:verificarVoto} se puede encontrar información acer de cómo se realiza la verificación de un voto individual obtenida de la web de documentación de Helios Voting.
								\newline
\todo[inline]{CAPTURA PANTALLA}
					\end{description} 
					
					
					
				\subsection{Totalización}\label{solucion_totalizacion}
				
					La totalización de los votos en el sistema se realiza a través de procedimientos criptográficos.
					
					Los votos emitidos han sido almacenados cifrados en la base de datos. De ellos, han sido descartados aquellos que no fuesen el último emitido en aquellos casos en los que un votante votó más de una vez.
					
					Por medio del homomorfismo, no es necesario que se descifren los votos para totalizar el resultado de la elección.
					
					Los votos no se descifran, se totalizan los votos cifrados y lo que se descifra es el resultado de esta suma.
					
					En el código se muestra que para cada voto final de cada votante, aquél se añade a la totalización. Una vez todos añadidos, se almacena la totalización, encriptada, a la espera de ser descifrada.

					\begin{lstlisting}[language=Python]
 def compute_tally(self):
    tally = self.init_tally()
    for voter in self.voter_set.exclude(vote=None):
    	# Para cada voto final de cada votante, se añade a
    	# la totalización
      tally.add_vote(voter.vote, verify_p=False)

	# La totalización, cifrada, se almacena a la espera 
	# de ser descifrada.
    self.encrypted_tally = tally
    self.save()						
 
 # Class Tally 
 def add_vote(self, encrypted_vote, verify_p=True):
    # do we verify?
    if verify_p:
      if not encrypted_vote.verify(self.election):
        raise Exception('Bad Vote')

    # for each question
    for question_num in range(len(self.questions)):
      question = self.questions[question_num]
      answers = question['answers']
      
      # for each possible answer to each question
      for answer_num in range(len(answers)):
        # do the homomorphic addition into the tally
        enc_vote_choice = encrypted_vote.encrypted_answers[question_num].choices[answer_num]
        enc_vote_choice.pk = self.public_key
        self.tally[question_num][answer_num] = encrypted_vote.encrypted_answers[question_num].choices[answer_num] * self.tally[question_num][answer_num]

    self.num_tallied += 1
					\end{lstlisting}

A continuación se muestra que los votos son, efectivamente, totalizados 


				\subsection{Difusión de resultados}
				
			
				
			
			
			
			
			\todo[inline]{¡¡ Comentado ya en el apartado \ref{solucion_appAndroidAutenticacion} !!}
			
							
			\section{Diseño de la interfaz de usuario}\label{diseño_interfaz_usuario}
				Se ha realizado una renovación de la interfaz de usuario del sistema original Helios. La interfaz original, si bien no tenía grandes problemas de visualización, ha resultado no adaptarse correctamente a los dispositivos móviles, con pantallas de menor tamaño y una forma diferente de ser utilizadas, ya que los usuarios suelen interactuar con diferentes hábitos al visitar la misma página web desde un dispositivo de escritorio o uno móvil.
				
				Las modificaciones más importantes se han realizado sobre la estructura de construcción de las páginas y sobre el estilo que en ellas aplica.
				
				Se ha intentado que las páginas cumplan con el estándar W3C y con reglas básicas de accesibilidad.
				
				Para la interfaz de usuario hay varias necesidades que se han debido de satisfacer.
				
				Por un lado, la imagen corporativa. Al tratarse de un proceso electoral diseñado para una entidad, la plataforma en la que se basa debería mostrar inequívocamente la imagen de la entidad que lo organiza.
				
				Otro aspecto a tener en cuenta será la adaptación a dispositivos móviles, pues lo que se busca es el voto seguro desde este tipo de dispositivos, algo que no cubre con suficiencia la versión actual de Helios Voting.
				
				\subsection{Estructura de la página web}
					\todo[inline]{Cambios en la interfaz original de Helios. Responsive....}
					El principal reto en cuanto a las modificaciones necesarias en la interfaz del sistema original Helios han correspondido a convertir las páginas en \textit{responsive}. Con ello, lo que se busca es adaptar la visualización de las diferentes páginas en distintos dispositivos, con diferentes recursos y distintos tamaños de pantalla, así como la capacidad de adaptarse, en un mismo dispositivo, a una situación en la que la pantalla se observa en vertical y se gira a horizontal o viceversa.
					
					Para llevar a cabo esta tarea, nos hemos centrado en las hojas de estilo existentes a las cuales se le han realizado modificaciones. Principalmente, se han incluido reglas que aplican dependiendo del ancho de la pantalla que 
					
				\subsection{Estructura de la aplicación móvil}
					\todo[inline]{Interfaz de usuario de la app.}
					La interfaz de usuario de la app Android necesaria para ingresar en el sistema con los certificados digitales del DNIe 3.0 no ha sido modificada ostensiblemente.
					
					Aunque es una parte primordial del sistema y su adaptación ha requerido bastante estudio y desarrollo, realmente al final no se utiliza durante un tiempo suficiente. Por ello, para el prototipo se ha decidido no invertir demasiado tiempo en su modificación estética, por lo que se ha reutilizado la diseñada originariamente por los desarrolladores de la app original de la DGP.
					
				\subsection{Accesibilidad}
					\todo[inline]{Destacar accesibilidad}
%\iffalse					
%				\subsection{Imagen corporativa}
%					\todo[inline]{Como imagen de marca, bla bla bla, al no haber un logo del proceso, bla bla bla, se puede introducir uno o utilizar el de la Universidad, bla bla}
%					La interfaz de Helios Voting se corresponde con un sistema neutro para realizar elecciones en la plataforma web de ejemplo que tienen publicada junto con el código fuente del proyecto.
%					
%					Esta interfaz está bien para el propósito que tiene el sistema original, que es, por un lado, mostrar un ejemplo de funcionamiento del proyecto y, por otro, dar una herramienta funcional para la realización de pequeños procesos electorales seguros por Internet para grupos reducidos que no necesiten una implementación propia.
%					
%					A la hora de utilizar esta herramienta para montar un sistema electoral propio, en infraestructuras de un cliente, esta interfaz no se corresponde con la que debería tener un proyecto diseñado para dicho clienta.
%					
%					Cualquier proceso electoral suele y debe tener una imagen corporativa propia que pueda identificarse claramente con el propio proceso y con las autoridades que lo organizan, con la finalidad de que el votante identifique claramente el origen del proceso y no dé lugar a equívocos, además de que, en cierto modo, aumentan la seguridad del mismo en el proceso.
%					
%					La Universidad no parece tener publicada una imagen de marca, con reglas y recomendaciones que definan el estilo que deben tener aquellas webs y documentos que se desarrollen o publiquen en su nombre. No obstante, se observa en su web que sí la tiene. Ya sea en los colores utilizados, en el diseño del logo y en la definición de los documentos publicados en su web.
%					
%					Por ello, se observa necesario implementar una imagen en el sistema que se corresponda con la Universidad. Al no publicar esta unas guías de imagen de marca, lo correcto será proponer un diseño de los sistemas inspirado en los que utiliza actualmente la Universidad en su web oficial o en los documentos que publica. El fin de este diseño integral adecuado será ayudar al usuario a identificar el organizador del proceso electoral, al mismo tiempo que simplifique el proceso de votación, o al menos, no lo complique.
%					
%					Utilizando como base la interfaz actual del proyecto Helios se le realizará una serie de modificaciones para realizar este cambio de marca.
%					
%					Por un lado, junto al logo de la Universidad, es conveniente diseñar un logo que represente la Elección. Esto dota al proceso de una imagen propia, aunque asociada a la entidad organizadora, con la que se trata de transmitir la importancia y seriedad del Proceso al usuario.
%					
%					La elección del juego de colores de los sistemas, tanto de las webs de los sistemas de Identificación y Voto como de la app de Android se basará en los colores de la web actual de la Universidad San Pablo CEU. La estructura de las páginas webs del sistema, no obstante, no será similar a la de la Universidad, ya que tratan información diferente y ésta no es adecuada para el flujo del usuario en el sistema de votación.
%					
%					Para el prototipo a implemetar se ha decidio, no obstante, utilizar la gama de colores que ofrece la librería Bootstrap, sin tener en cuenta estas reglas de marca.
%					
%					
%					\notasInfo[inline]{Dar una muestra de colores y de logos de la elección}
%					
%					\begin{figure}[!ht]
%						\centering
%							\includegraphics[width=.5\textwidth]{imgs/logo_usp_ceu.jpg}
%						\caption{Logo de la Universidad San Pablo CEU en su web}
%						\label{fig:logo.universidad_san_pablo_ceu}
%					\end{figure}
%				
%				
%					\notasInfo[inline]{Colores...accesibilidad!}				
%				
%				Uno de los requisitos que debe cumplir un sistema de votación es que sea accesible para el mayor número de personas posible. Desde el punto de vista de la interfaz esto implica que:
%				\begin{itemize}
%					\item Debe funcionar correctamente en la mayoría de los navegadores web.
%					\item Debe cumplir con los estándares de accesibilidad (WCAG, AA+)
%					\item La web debe cumplir con el estándar del consorcio W3C.
%					\item La información presentada debe cumplir con la internacionalización (i18n) necesaria para llegar al mayor número posible del censo y de los observadores.
%				\end{itemize}
%				
%\fi
				
				
				
				
%\iffalse				
%				\todo[inline]{Desde aquí hasta el comienzo de \ref{solucion_protocolo} hay que moverlo a Análisis.}
%				En varios de los sistemas estudiados que se han desarrollado para intentar implantar el voto electrónico a un nivel medio, como pueden ser los mexicanos SELES \ref{seles} y SEVI \ref{sevi} o los españoles de Víctor Moreno \cite{moreno07} \notasDuda{???????}o Votescript \ref{ivotingVotescript}\notasDuda{???????} se observa que se realiza una división del proceso electoral en cuatro fases (Registro, Votación, Consolidación de resultados y Auditoría). En el desarrollo de este sistema vamos a identificar las mismas fases, pero con matices.
%				
%				Así, en una primera visión global del sistema, en este se definen cuatro fases:
%				\begin{itemize}
%					\item Preelectoral
%					\item Votación
%					\item Consolidación de resultados
%					\item Postelectoral
%				\end{itemize}
%				
%				Realmente, la mayor diferencia con las fases definidas en los esquemas anteriores se corresponden con el alcance de la primera y la última fase.
%				La fase Preelectoral, denominada comúnmente en los ejemplos estudiados en la Introducción como fase de Registro, en este sistema tiene un alcance mayor. En este proceso electoral no se requiere que el votante se registre para poder votar. El censo lo proporciona la Autoridad Electoral y se carga en el sistema. Igualmente, en los días previos a la jornada electoral el sistema permitirá a los votantes comprobar si están en el censo y qué información contiene éste, tanto personal - para asegurarse de que podrán identificarse - como de permisos de cara a realizar la votación.
%				
%				
%				
%				Las fase de Votación también tiene un alcance diferente. En primer lugar, empieza con la identificación del votante en el sistema electoral. Una vez el votante ha sido correctamente identificado por el sistema (tal como lo haría contra los miembros de la mesa en el voto tradicional), debe recibir una boleta electrónica que le ofrezca las opciones entre las que, por su circunscripción, deba elegir la que desea votar. Una vez seleccionado, es el momento en el que realmente el votante realiza la votación, traspasando el voto de forma digital al sistema, a la \textit{urna digital} donde se anonimizarán y almacenarán hasta la fase de consolidación.
%				
%				En la fase de consolidación de resultados, el sistema se encargará del conteo de los votos que han sido emitidos
%				\todo[inline]{continuar...}
%				
%				La fase Postelectoral, que denominan Auditoría, prefiero dejarla con este nombre, ya que considero que la auditoría del sistema es una operativa que se realiza durante toda la jornada electoral, no sólo al finalizar ésta. No obstante, es cierto que al final se llevarán a cabo auditorías de los resultados y el funcionamiento. Además de las auditorías llevadas a cabo por los auditores \textit{oficiales}, se va a implementar un mecanismo que permita a los propios votante auditar que su voto ha sido correctamente incluido y contado en el proceso. Esta fase postelectoral también tiene más pasos ... \todo[inline]{continuar con fase postelectoral}
%				
%			\todo[inline]{Antes de este punto hay que hacer un resumen de los diferentes esquemas de votación, teniendo estos como Firma ciega, mixnets, etc...}
%\fi

%\iffalse
%			\subsection{Protocolo}\label{solucion_protocolo}
%			\textst{
%				Como se ha comentado en capítulos anteriores, hay una multitud de soluciones propuestas para el voto telemático.
%				
%				Teniendo en cuenta el objetivo de este Proyecto Fin de Carrera, de los sistemas implementados a gran escala, a nivel nacional o regional, podemos destacar Estonia, Noruega y los cantones suizos como las tres experiencias más exitosas y aquellas de las que se pueden estudiar las soluciones, esquemas y protocolos utilizados. No obstante, el alcance de las mismas supera sobremanera el de este proyecto. Igualmente, muchas decisiones las toman en base a satisfacer requisitos que resultan muy importantes en su análisis, pero que en este trabajo no se ha considerado que tengan igual trascendencia, y viceversa, por lo que se han de tomar diferentes consideraciones frente a los mismos problemas dependiendo del impacto que suponen en cada proyecto.
%				}
%				También se han presentado casos de proyectos de voto telemático pensados a menor escala. Entre ellos, hay muchas soluciones que, en parte, podrían satisfacer los requisitos de este proyecto. No obstante en ninguno de ellos encontramos un protocolo que se adapte completamente a los requerimientos planteados, ya que, en algún momento, se analiza un elemento que los hace diferir. Por ejemplo, un proyecto ya maduro como Votescript (\ref{ivotingVotescript}) realiza un estudio académico y técnico muy profundo acerca del voto telemático pero, por su propia definición, el modelo de identificación y emisión del voto lo sitúan físicamente en centros de votación. Este elemento es diferencial para este proyecto, pensado en el voto telemático remoto, aunque puede integrarse cuando se estudian alternativas para que aquellos votantes que, por algún motivo, no pueden o quieren votar por Internet de forma remota tengan la oportunidad de ejercer su derecho de sufragio desde un lugar habilitado para ello por la propia Escuela.
%				\textst{
%				A partir de los esquemas criptográficos estudiados y con ayuda de algunos protocolos ya publicados en otros proyectos, el siguiente paso es diseñar el protocolo de votación que se adapte a las necesidades del Proyecto, cumpliendo con los requisitos y asegurando los niveles de seguridad planteados.
%				
%				En muchas de las soluciones estudiadas se observa que no recibe la importancia necesaria la fase de identificación del votante. Los mecanismos de identificación y autenticación del mismo resultan laxos desde el punto de vista de la seguridad ante el fraude electoral. Por ello han sido descartadas las soluciones basadas en identificación por medio de bases de datos con el típico protocolo de usuario/contraseña o incluso con elementos de seguridad de una generación algo posterior, como pin, patrones, captchas, operaciones aritméticas o métodos similares con mayor o menor complejidad. Igualmente, se han descartado aquellos métodos de identificación que requieran la presencia física del votante frente a los responsables de la mesa de votación, ya que se busca el diseño de un sistema remoto. Así descartamos protocolos de identificación como los publicados por Votescript, en el que el votante acude a un centro o local de votación, se identifica ante la mesa electoral y recibe un token criptográfico personalizado con el que se le permite ejercer el sufragio.
%				
%				La mayoría de las soluciones estudiadas previamente a la realización de esta memoria centran sus esfuerzos en la fase de votación. Buscan la elaboración de un protocolo robusto, basado en esquemas criptográficos, que permita la mayor seguridad posible al cumplimiento de los requisitos fundamentales del voto electrónico, dotando al sistema de privacidad del votante, 
%			}
%				\todo[inline]{Hay que modificarlo. Es anterior a la decisión de utilizar Helios}
%\fi				
%				
				
				
				
				
				
				
				
				
				
				
				
				
				%\subsubsection{Descripción del sistema}\label{solucion_descripcion}
				%El sistema contará de cinco fases, determinadas por el flujo temporal de la votación.
				%Preelectoral, Identificación, Votación, Escrutinio y publicación de resultados.
				%Adicionalmente, se tendrá en cuenta un sistema de auditoría, de carácter transversal a este flujo, ya que debe estar disponible durante todo el proceso de votación.
				%
				%\todo[inline]{No he podido conseguir reglamentación oficial de la elección, así que, básicamente, propongo yo las fases y la problemática ... esto, con palabras aquí escrito y bien puesto }
				%
				
%\iffalse
%				\section{ESTO ES EL PFC}
%				\todo[inline]{ESTO NO VA EN EL PFC, ES UNA EXPLICACIÓN PARA TENER PRESENTE QUÉ ES EL PFC YU PODER DESARROLLAR LA MEMORIA EN TORNO A LA IDEA QUE TENEMOS.}
%				El sistema que se propone en este PFC es un sistema integral. Busca sostener el proceso electoral desde el comienzo hasta el final del mismo. Por ello empieza en el momento mismo de definición del censo y no termina hasta que la publicación de resultados y su auditoría son oficializadas por el órgano rector de la Elección.
%				
%				La primera fase, preelectoral, es aquella previa al día electoral, en la cual se definen las bases en las que se rige el proceso electoral.
%				
%				Así, es imprescindible cumplimentar varias acciones por parte de los desarrolladores, administradores y órgano electoral.
%				
%				En primer lugar, es fundamental la elaboración de un censo electoral. En éste se recogen los potenciales votantes, aquellos con derecho a voto, identificando, además, la circunscripción \notasDuda{Cir-cuns-crip-ción??? No hay una forma mejor de expresarlo??} a la que pertenece. En unas elecciones legislativas, una circunscripción electoral se puede definir como el conjunto de electores a partir del cual se procede la distribución de los escaños asignados, en función de la distribución del los votos sufragados. En las elecciones legislativas españolas, las circunscripciones se corresponden con las provincias españolas (excepto en el caso de Aturias, que está subdividida en 3 distritos electorales, y la Región de Murcia, que lo hace en 5). Esto significa que del total de diputados que se eligen en este proceso para la totalidad de España, en vez de repartirlos con el recuento total de los votos, se reparten los cargos por cada circunscripción, dependiendo del número de electores de cada una, con lo que los votantes censados en una circunscripción, digamos por ejemplo la provincia de Málaga, elegirán a un número determinado de diputados que serán quienes les representen en el Congreso junto a los elegidos en el resto de territorios españoles. En las Elecciones al Parlamento Europeo, sin embargo, España actúa como una única circunscripción, por lo que los diputados que representarán al país en la cámara supranacional se obtendrán a base de repartir los escaños con respecto al total de votos recogidos en todo el territorio español.
%				
%				Algo parecido es lo que se va a definir en el censo electoral. Además de recoger de forma unívoca a los electores con derecho al voto, se tendrán que sumar las ************\notasCambio{*********} necesarias para su correcta identificación, así como la ``circunscripción'' a la que pertenece, es decir, el grupo sobre el que debe escoger a sus representantes, con el fin de que la opción de voto que el sistema le presente y la que introduzca en el sistema sea correcta.
%				
%				Se vislumbran aquí dos requisitos del voto electrónico que necesitan ser satisfechos para la integridad del proceso electoral.
%				
%				En primer lugar, es básico que el censo defina claramente los votantes con derecho al voto y provea de la información necesaria para que se pueda comprobar la identidad del votante en el momento en el que se disponga a votar. En las elecciones con voto tradicional esto se conseguía añadiendo datos personales tales como el número del DNI, del Pasaporte o, en caso de estas elecciones, el número de identificación del alumno. Así, al acudir a la mesa electoral todos los votantes tenían estos datos con los que se podían identificar frente a los miembros de la misma, los cuales tienen la potestad de permitirles votar o no.
%				
%				Integridad del voto. El hecho de relacionar cada votante con una ``circunscripción'' es esencial a la hora de mantener la integridad de la votación, pues hay que tener en cuenta los candidatos a los que cada votante puede votar, ya que no son los mismos para todos. Igual que en unas legislativas españolas un votante de Málaga no elige entre los mismos candidatos que lo hace un votante de Lugo, en estas elecciones, un alumno elige sus representantes entre los delegados de curso, mientras que los profesores, por su parte, lo hacen entre otros colegas profesores. Es indispensable, pues, gestionar correctamente estas relaciones ya que no se deben recoger votos de votantes a candidatos a los que no tiene derecho a elegir.
%				
%				En el caso de esta elección, es la propia Escuela Politécnica Superior la que debe proveer el censo oficial a los administradores del sistema, los cuales procederán a cargarlo en el mismo a través de los mecanismos implementados para ello.
%				\notasInfo[inline]{(Aquí encontramos un primer punto de auditoría importante).}
%				\notasInfo[inline]{(En algunos países, en vez de elaborarse un censo oficial, son los propios votantes los que han de registrarse)}
%				
%				
%				Es requisito de la Institución que convoca el proceso electoral el definir las ``reglas del juego''. En este caso, el órgano de la EPS encargado de la celebración de las elecciones ha de definir los mecanismos de votación para que el sistema se pueda adaptar y mantener .......
%				\todo[inline]{continuar...}
%				
%				Candidatos. Es necesario que los candidatos puedan presentar su candidatura e incorporarse al sistema para que éste pueda gestionarlos para presentarlos como opciones a los votantes determinados, además de en el momento de consolidación de los votos y posterior publicación de resultados.
%				En muchos procesos se realizan desarrollos que permiten a los partidos políticos registrar sus listas electorales y/o candidatos de forma remota durante el plazo determinado que la Ley Electoral les indica. Así, los partidos inscriben a sus representantes en el proceso electoral. En el caso de esta elección, debido a su carácter tan localizado no vemos necesidad de ello y corresponde a la Escuela Politécnica Superior proporcionar el listado de candidatos elegible y las circunscripciones a las que se presentan.
%				\todo[inline]{Para futuros desarrollos, pensando en la escalabilidad del sistema, se podría desarrollar este punto para que este proceso sea independiente de los órganos electorales de la EPS}.
%				
%				En las elecciones tradicionales, es también necesaria la formación de las mesas electorales, con la definición del número de ellas que son necesarias y la designación de los miembros que van a formar parte de ella. En una elección electrónica y remota, como la que hemos diseñado, el concepto de mesa se puede mantener, sobre todo para poder gestionar las circunscripciones y para continuar con las estadísticas de participación tradicionales, basadas en agrupaciones y disgregaciones de mesas. Sin embargo, al transformarse en un concepto lógico, se pierde el sentido de la designación de los miembros de mesa, por lo que no será un punto a tener en cuenta en el proceso.
%				
%				
%				\todo[inline]{Pasamos a la siguiente fase: Identificación}
%				Una vez acometidas todas las gestiones de la fase preelectoral, pasamos a la fase correspondiente al llamado Día Electoral (aunque realmente la elección en vez de en un día, se pueda alargar a lo largo de un período de tiempo mayor).
%				Tratando de emular a las elecciones tradicionales, esta fase comienza con la apertura de los colegios electorales y las mesas que los componen. En el caso digital, serán los miembros designados por la Junta Electoral los que, previa identificación y requerimiento de sus credenciales digitales, pongan en marcha el sistema en su fase electoral. Será una apertura de los colegios de forma virtual, permitiendo que los votantes puedan acceder al sistema y proceder a votar.
%				La fase de identificación del votante es una fase realmente importante. En las elecciones de voto tradicional, el proceso normal consiste en que el votante acude a la mesa electoral y muestra a los miembros de mesa alguna identificación de curso legal, respaldada por alguna institución estatal reconocida y capacitada. Los miembros de la mesa electoral contrastan la identificación presentada con la información recogida en el censo electoral de dicha mesa y deciden si es suficiente o no para permitir al votante introducir su voto en la urna. En el caso de las elecciones legislativas españolas los documentos que se pueden mostrar son DNI, pasaporte o permiso de conducir. Todos estos documentos son válidos para votar incluso estando caducados. Han de mostrar la fotografía del votante para permitir la identificación por parte de los miembros de mesa, por lo que, aunque sea válido que estén caducados, no se permite utilizar el resguardo de DNI en trámite.
%				\todo[inline]{En el caso de las elecciones de la EPS, los documentos válidos son .-......}
%				Es requisito el sustituir este sistema de identificación del elector por otro en el que no sea necesaria la presencia física de éste ni de los miembros de mesa para permitir el voto, aunque manteniendo el mismo nivel de seguridad en el proceso. Aquí se hace indispensable estudiar las opciones de identificación digital que se pueden implementar para .............
%				\todo[inline]{continuar}
%				
%				Lo ideal es disponer de documentos que contengan tokens criptográficos propios que puedan ser utilizados en los diferentes procesos de identificación y voto. Por ello, vamos a utilizar documentos que los disponen.
%				
%				Así, los documentos válidos para ejercer el derecho al voto serán el DNIe (tanto la primera versión como la denominada 3.0, presentada en enero de 2015) y la TUI \notasMejorar{***InfoTUI***} de la Universidad San Pablo-CEU. En sendos documentos encontramos elementos criptográficos que identifican unívocamente a su dueño. Además encontramos en ellos certificados para la firma digital, que serán necesarios para la fase de votación.
%				
%				El votante se identifica con su documento digital de forma remota. Es necesario que disponga de un lector de chip electrónico conectado al dispositivo desde el que va a realizar el voto, aunque utilizando DNIe con lector de chip sin contacto, no haría falta si se hace uso de un dispositivo con sensor de radiofrecuencia, con capacidad para leer información a través de NFC.
%				
%				A través de la app Android (o la app web), el votante accede al servicio de votación por Internet. El primer paso es la identificación del votante. Es la primera vez que hará uso de los certificados del DNIe. En este caso, la app leerá (con NFC o chip con contacto) el certificado de Autenticación del DNIe, por el cual se asegura la identidad del votante. Con la identidad del votante verificada (por la DGP), se contrasta con el censo, para comprobar:
%				\begin{itemize}
%					\item Si el votante existe en el censo.
%					\item Si el votante ha votado previamente.
%					\item Los datos censales del votante, para comprobar circunscripción, mesa electoral y, por ende, ser capaz de obtener los candidatos entre los que puede escoger.
%				\end{itemize}
%				
%				Una vez verificado el votante y comprobados sus datos censales, se procede a construir la boleta con los candidatos que entre los que le corresponde elegir basándose en su circunscripción electoral. El sistema ha de presentar la boleta al votante y permitir que éste marque la o las opciones que permita el sistema electoral para constituir el voto a emitir.
%				
%				Una vez constituido el voto (papeleta), hay que proceder a la votación digital. Para ello nos basamos en cifrado y firma ciega. Así, el primer paso es que la app utiliza la clave pública de la Entidad Electoral para cifrar el voto. Con el voto cifrado, el votante ha de firmarlo. La firma se realiza con el certificado de Firma que posee el DNIe. Así, el votante firma un conjunto de [voto cifrado + votante], que es el paquete que se pasará al subsistema de gestión del voto.
%				
%				Una vez el votante ha emitido el voto, el sistema le devuelve un resguardo (código QR como en Estonia, un código alfanumérico, no sé todavía) con el cual puede verificar que el voto ha sido correctamente incluido en el sistema. Además, podrá verificar que el voto ha sido correctamente incluido en el escrutinio. \notasCambio[inline]{(No sé si con este resguardo debe poder llegar a la opción de voto elegida, todo depende de cómo tomemos el requisito de coerción y qué es lo que menos le afecta)}
%				
%				El votante puede votar tantas veces como desee cambiar su voto \notasInfo{Así disminuimos el riesgo de coerción}. Para ello, hay un protocolo por el cual cuando un votante emite su voto, todos los anteriores son anulados. \todo[inline]{Hay que definir el protocolo para la anulación de votos por 'revoto'}
%				
%				El sistema de gestión del voto es el encargado de los votos sufragados durante la jornada electoral. El sistema almacena los votos firmados (voto cifrado + votante) en una \textit{urna} digital durante el tiempo que dura la jornada electoral. En caso de recibir un voto de un votante que ya previamente había emitido su voto, debe ser capaz de anular los votos anteriores que éste hubiese sufragado\notasInfo{Como digo antes, hay que definir cómo se hace esto de anular votos emitidos}.
%				Una vez que el Administrador del Proceso Electoral da por terminada la Jornada Electoral, los Miembros de la Junta Electoral utilizan sus claves para formar la clave maestra que permite dar por terminada la fase de votación y comenzar con el Escrutinio.
%				La primera fase del Escrutinio es que los votos firmados deben ser \textit{anonimizados}. Esto lo vamos a realizar en dos pasos. Primero, comprobamos la validez de la firma del voto firmado. Si la firma se corresponde con u voto a descartar, se elimina. Si la firma es válida, se extrae (abrimos el sobre donde va la info del votante y el sobre con su voto secreto) del contenido del voto firmado tanto el voto cifrado como la información asociada del votante. Por un lado, la información del votante se almacena para sacar un listado de votantes (que podrá compararse con el resultado de votantes del censo). Por otra parte, los votos cifrados pasan a otro almacén ya sin asociación con su votante. Para terminar de separar los votos de sus votantes, pasamos por un proceso anonimizador que ... \todo[inline]{Aquí entra en juego ElGamal y sus amigos o las mixnets}.
%				Una vez tenemos los votos separados de sus votantes, procedemos a la siguiente fase del escrutinio, que es la de (abrir el sobre del voto secreto) descifrar el voto. El sistema necesita la clave privada de la Entidad Electoral para descifrar los votos que, recordemos, están cifrados con la clave pública. Con esta clave privada, extraemos el contenido del voto cifrado y obtenemos cada uno de los votos en plano de las urnas digitales.
%				Una vez obtenidos el conjunto de los votos en plano de cada urna digital, podemos proceder a la consolidación de los votos. Se realiza el conteo de cada urna y, con los resultados obtenidos, se puede realizar la totalización para llegar al resultado final de la Elección.
%				
%				El último paso del sistema será el de la Difusión de los Resultados. El sistema de Escrutinio (o Totalización) informa de los resultados al módulo de Difusión, el cual les aplicará el formato necesario para cumplir con las necesidades de publicación de los mismos. En el caso del Proceso Electoral asociado a este proyecto, una web y diversos listados PDFs para poder ser cotejados.
%
%				Sería muy interesante que, como en Estonia, los votantes tuvieran una herramienta para poder verificar que su voto ha sido correctamente incluido y escrutado en el Proceso.
%				
%				Paralelamente a todo el proceso, cada subsistema ha de generar una serie de registros, ficheros logs, que puedan ser visualizados por un conjunto de auditores, observadores u otro grupo de profesionales que tengan que dar cuenta del correcto funcionamiento del Proceso y de la transparencia del mismo, así como del éxito técnico del Sistema.
%\fi		
	
	
	\section{Prototipo}\label{solucion_prototipo}
		Para implementar el software desarrollado en este Proyecto, se decidió montar un prototipo que cumpliera con los requisitos funcionales y diera una muestra de las capacidades del mismo a una escala reducida.
	
	
	
		Para ello, había que desarrollar los 3 módulos de software:
		\begin{itemize}
			\item Servidor de votación
			\item Servidor de identificación y autenticación
			\item App Android de identificación con DNIe
		\end{itemize}
	
	
		\subsection{Arquitectura física}\label{solucion_prototipo_arquitecturaFisica}
			Para montar los dos servidores, se decidió pasar de las máquina virtuales en las que se desarrollaron al uso de dos Raspberry Pi como base hardware.
		
		
		
			Raspberry Pi es un computador de placa reducida, única o simple de bajo coste desarrollado por la Fundación Raspberry Pi, con base en Reino Unido, con el objetivo de estimular la enseñanza de la informática en las escuelas.
			
			
			
			El lanzamiento del primero de los modelos fue a finales de febrero de 2012. Hasta el momento, Raspberry Pi ha comercializado 5 modelos de placas, desde la Raspberry Pi 1 Modelo A en 2012 hasta la Raspberry Pi 3 Modelo B, lanzada en 2016.
			
			
			
			Los modelos con los que se ha montado el prototipo son:
		
		
	
			\begin{description}
		
				\item[Servidor de votación]	Raspberry Pi Model 3 B
		
				\item[Servidor de identificación y autenticación] Raspberry Pi Model B (Rev. 2.0, 512Mb)
		
			\end{description}
	
		
	
			\todo[inline]{Incluir fotos de las raspberrys					}
		
			
	
			En la tabla \ref{tab:DetallesTecnicosRaspberryPi} se detallan y comparan las características de ambos modelos de hardware.
	
		
			\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
			\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
			\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
			\begin{table}[ht]
				%\fontsize{5}{4}\selectfont
				\small
				\def\arraystretch{1.25}%  1 is the default, change whatever you need
				\setstretch{1}
				\begin{threeparttable}
					\centering
					%\begin{tabular*}{0.95\textwidth}{@{\extracolsep{\fill}}|L{0.2\textwidth}|L{0.35\textwidth}|L{0.35\textwidth}|}
					\begin{tabular*}{\textwidth}{| L{0.2\textwidth} | L{0.356\textwidth} | L{0.356\textwidth} |}
						\hline
						\begin{center}
							\textbf{Característica}
						\end{center}
						& 
						\begin{center}
							\textbf{Raspberry Pi Model B \\(Rev. 2.0, 512Mb)}
						\end{center}
						& 
						\begin{center}
							\textbf{Raspberry Pi Model 3 B}
						\end{center}
						\\
						\hline
						Fecha de lanzamiento & Q4 2012 						& Q1 2016 	\\
						\hline
						Precio\tnote{a} & US\$35 						& US\$35 	\\
						\hline
						SoC (System-on-a-chip) & Broadcom BCM2835 			& Broadcom BCM2837 	\\
						\hline
						CPU & 700 MHz ARM11 ARM1176JZF-S core	& 1.2GHz 64-bit quad-core ARMv8 Cortex-A53 \\
						\hline
						GPU & Broadcom VideoCore IV, OpenGL ES 2.0,OpenVG 1080p30 H.264 high-profile encode/decode, 250 MHz	& Broadcom VideoCore IV, OpenGL ES 2.0,OpenVG 1080p60 H.264 high-profile encode/decode, 400 MHz \\
						\hline
						Memoria SDRAM & 512 MB 			& 1024 MB \\
						\hline
						USB & 2 x USB 2.0 						& 4 x USB 2.0 \\
						\hline
						Salida de vídeo & Composite video, Composite RCA, HDMI 	& HDMI	\\
						\hline
						Salida de audio & Conector de 3.5mm, HDMI	 		& Conector de 3.5mm, HDMI	\\
						\hline
						Almacenamiento & Ranura MicroSD	& Ranura MicroSD \\
						\hline
						Redes & 10/100 Ethernet (RJ-45), WiFi vía USB dongle	& 10/100 Ethernet (RJ-45), WiFi 802.11n integrada, Bluetooth 4.1 \\
						\hline
						Periféricos de bajo nivel & 26 x GPIO pins, Serial Peripheral Interface Bus (SPI), $I^{2}C$, $I^{2}S$, UART	& 40 x GPIO pins, Serial Peripheral Interface Bus (SPI), $I^{2}C$, $I^{2}S$, UART, I2C IDC Pins  \\
						\hline
						Consumo energético & 700 mA, (3.5 W) 			& 800 m(4.0 W) \\
						\hline
						Fuente de alimentación & 5 V (DC) vía Micro USB o pines GPIO	& 5 V (DC) vía Micro USB o pines GPIO \\
						\hline
						Tamaño & 85.0 mm x 56.0 mm x 17 mm	& 85.6 mm x 56.5 mm x 17 mm \\
						\hline
						Peso & 40g	& 45g \\
						\hline
					\end{tabular*}
					\begin{tablenotes}
						\scriptsize
						\item[a] \textbf{Precio}: Precio en el momento de su lanzamiento.
					\end{tablenotes}
					\caption{Detalles técnicos de las Raspberry Pi utilizadas en el prototipo.\label{tab:DetallesTecnicosRaspberryPi}}
				\end{threeparttable}
			\end{table}
		
			El Sistema Operativo elegido para ambos servidores es Raspbian \footnote{\url{https://www.raspberrypi.org/downloads/raspbian/}}, una distribución de GNU/Linux basada en su origen en Debian Wheezy. Al ser un sistema basado en GNU/Linux, se infiere que es software libre y de código abierto. No obstante, para el prototipo, se ha instalado la versión estable de Raspbian a fecha de Noviembre de 2016, en la cual, el Sistema Operativo se basa en la versión de GNU/Linux Debian Jessie \footnote{\url{https://www.raspberrypi.org/blog/raspbian-jessie-is-here/}}, posterior a Wheezy.
		
		\subsection{Arquitectura de red}\label{solucion_prototipo_arquitecturaRed}
		La arquitectura de red propuesta para el prototipo incluye varios elementos:
		\begin{itemize}
			\item Servidor de identificación
			\item Servidor de votación
			\item Dispositivos de votación
			\item Router
		\end{itemize}
		
		Los dos servidores están conectados a la misma red. Particularmente, por motivos de diferencia en los modelos de las dos Raspberry Pis en las que están montados, uno de ellos - el Servidor de Identificación - utilizará un dongle USB de conexión a la red, mientras que el Servidor de Votación hace uso de la placa de red interna de su Raspberry Pi.
		
		En la configuración del sistema se puede optar porque el sistema funcione por Internet o en una Intranet. La idea es que el servicio sea ofrecido por Internet y así se diseñó, pero por motivos de infraestructura a la hora de presentarlo, se decidió desarrollar la posibilidad de funcionar también en una intranet.
		
		Para ello, hay que configurar tanto el router como la app Android y los servidores. En el caso del router, para funcionar por Internet habría que abrir los puertos necesarios y realizar su pertinente redireccionamiento a los puertos de los servidores necesarios.
		
		Una configuración típica de esta forma de conexión a través de Internet incluye configurar estos redireccionamientos en los puertos del router:
		

		\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
		\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
		\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
		\begin{table}[ht]
			\small
			\def\arraystretch{1.25}%  1 is the default, change whatever you need
			\setstretch{1}
				\begin{threeparttable}
					\centering
						\begin{tabular*}{\textwidth}{| L{0.18\textwidth} | L{0.1\textwidth} | L{0.18\textwidth} | L{0.09\textwidth} | L{0.304\textwidth} |}
							\hline
								
								\begin{center}
								\textbf{Servidor}
								\end{center}
								 & 
								 \begin{center}
								 \textbf{Puerto \\ externo}
								 \end{center}
								& 
								\begin{center}
								\textbf{IP servidor \\ interno}
								\end{center}
								& 
								\begin{center}
								\textbf{Puerto \\ interno}
								\end{center}
								& 
								\begin{center}
								\textbf{Descripción}
								\end{center}
								 \\
					\hline\hline
						
					\multirow{4}{*}{\textbf{Autenticación}} 	& 8662 & 192.168.1.144 & 442 	& Puerto de acceso al servidor Apache por HTTPS/TLS \tabularnewline
						
					\cline{2-5}
						
					& 8888 & 192.168.1.144 & 80 	& Puerto de acceso al servidor Apache por HTTP \tabularnewline
						
					\cline{2-5}
						
					& 8443 & 192.168.1.144 & 443 	& Puerto de acceso al servidor Apache por HTTPS/TLS \tabularnewline
						
					\cline{2-5}
						
					& 8022 & 192.168.1.144 & 22 	& Acceso SSH \tabularnewline
						
					\hline\hline
						
					\multirow{3}{*}{\textbf{Votación}}	 			& 8889 & 192.168.1.145 & 80 	& Puerto de acceso al servidor Apache por HTTP \tabularnewline
						
					\cline{2-5}
						
					& 8445 & 192.168.1.145 & 443 	& Puerto de acceso al servidor Apache por HTTPS/TLS \tabularnewline
						
					\cline{2-5}
						
					& 8044 & 192.168.1.145 & 22 	& Acceso SSH \tabularnewline
						
					\hline
						\end{tabular*}

						\caption{Port forwarding en la red de desarrollo.\label{tab:portForwarding}}
					\end{threeparttable}
			\end{table}
			
		
		
		En caso de la configuración del sistema para trabajar en intranet, por motivos de infraestructura, ya sea por una presentación como la de este propio proyecto o por querer realizar una votación cerrada, la propuesta implementada incluye un router simple funcionando sin conexión a Internet.
		
		El router utilizado ha sido XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX. \todo{incluir modelo del router para la presentación}
		
		