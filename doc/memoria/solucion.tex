\chapter{Solución}\label{solucion}
\lhead{Capítulo \ref{solucion}}
\rhead{Descripción detallada de la solución}
%*******************************************************************************
% *************************************************************************************************************** %
% 			SOLUCIÓN
% *************************************************************************************************************** %
%%%%%%%\section{Identificación y gestión de riesgos}\label{idGestRiesgos}
%*
%*
%*
%*
%*
%*

	%%%%%%%%\subsection{Identificación de riesgos}\label{identificacionRiesgos}
	\todo[inline]{He eliminado los diagramas que tenía porque ya no se corresponden con el nuevo sistema.}
	%\begin{figure}[htbp]
		%\centering
			%\includegraphics[width=1\textwidth]{imgs/sistema.png}
		%\caption{Diagrama de flujo del Sistema}
		%\label{fig:sistema}
	%\end{figure}
	%
	%\begin{figure}[htbp]
		%\centering
			%\includegraphics[width=0.60\textwidth]{imgs/flujoUsuario.jpg}
		%\caption{Esquema del flujo que sigue el votante}
		%\label{fig:flujoUsuario}
	%\end{figure}
	%\begin{figure}[htbp]
		%\centering
			%\includegraphics[width=0.60\textwidth]{imgs/flujoSistema.jpg}
		%\caption{Esquema del flujo del Sistema}
		%\label{fig:flujoSistema}
	%\end{figure}
		
			
		\section{Arquitectura del sistema}\label{solucion_arquitectura}
			Tal como se determina en el análisis (\ref{analisis}), la solución que se propone para este Proyecto consiste en la integración de tres componentes, adptados a las necesidades de una elección para la EPS.
			
			\begin{description}
				\item[Cliente:] En el lado cliente, de cara al usuario, se ha implementado una solución para poder acceder a las credenciales del chip sin contacto del DNIe 3.0. Esta implementación es una aplicación Android.
			
				\item[Servidor de autenticación:] Para permitir el acceso al sistema con las credenciales del DNIe, se utiliza un servidor de autenticación basado en el protocolo oAuth. La aplicación Android se conecta por HTTPS/TLS de forma segura al servidor web estableciendo un canal seguro utilizando el certificado del propio servidor y como certificado de cliente, el de identifiacación del DNIe. Este servidor es el que autoriza al usuario comprobando su identidad y consultando el censo de la elección.
			
			\item[Servidor de votación:] El servidor de votación es una versión adaptada del sistema Helios Voting. Se comunica con el cliente por HTTPS y el usuario, autorizado previamente, tiene la posibilidad de, dependiendo de su rol, crear y gestionar una elección, votar en ella y/o, simplemente, consultar los resultados.
			\end{description}
			
			\begin{figure}[!ht]
					\centering
						\includegraphics[width=.95\textwidth]{imgs/arquitecturaSistema.jpg}
					\caption{Arquitectura del sistema}
					\label{fig:arquitectura.sistema}
				\end{figure}
			
			\subsection{Cliente Android}\label{arquitectura_clienteAndroid}
			La aplicación Android de cliente es necesaria para poder utilizar el certificado de autenticación sin contacto incluído en el DNIe 3.0. Desde un ordenador de escritorio, con los drivers del DNIe instalados, el propio Sistema Operativo se encarga de la comunicación con los certificados del carnet. Con ellos, se puede establecer una conexión HTTPS/TLS segura contra un servidor web configurado para interactuar con este tipo de certificados.
			
			Para poder utilizar el DNIe sin contacto, se ha adaptado la aplicación original de la DGP para acceder a los certificados sin contacto del DNIe 3.0. Esta aplicación, una vez que se comunica con el chip sin contacto y extrae el certificado de autenticación, utiliza éste para poder establecer la comunicación HTTPS con el servidor de autenticación.
			
			Una vez el servidor de autenticación autoriza al cliente el acceso al servidor de votación, la navegación por la web se realiza a través de un navegador web del dispositivo. La propia aplicación Android es quien realiza la llamada al navegador para que se abra la aplicación y acceda a la página de inicio con el código de acceso necesario, obtenido del swervidor de autenticación, para que se puedean obtener los tokens que permitan al usuario interactuar con el sistema con priviliegios.
			
			\section{Servidor de autenticación}\label{arquitectura_servidorAutenticacion}
			El servidor de autenticación implementa el protocolo de autenticación oAuth 2.0 entre el usuario y el sistema. En concreto, se ha realizado un fork del proyecto \textit{django-oauth2-server}\footnote{\url{https://github.com/RichardKnop/django-oauth2-server}} desarrollado por Richard Knop. El objetivo era modificarlo para adaptarlo a diferentes necesidades teniendo en cuenta si el acceso es por la web o a través de la app Android. Además, era necesario que la autorización del usuario se realizara consultando el censo de usuarios y/o votantes de la Elección.
			 
			El servidor de autenticación se compone de un servidor web, el sistema de oAuth basado en Django que hemos comentado y una base de datos que contiene tanto permisos de aplicaciones y usuario como los propios usuarios con permiso de acceso al sistema de votación.
			
			El servidor web se configura para exponer un endpoint de entrada seguro, permitiendo el acceso por HTTPS. En dicha configuración es muy importante activar diversas características:
				\begin{description}
				
					\item[Servidor web:]
						El canal de comunicación entre el usuario y el sistema de autenticación es la web, el protocolo es HTTPS y la herramienta que gestiona estos accesos es el servidor web.
						
						Con el fin de establecer un canal HTTPS seguro entre usuario y servidor, es necesario que en su configuración se contemplen tres certificados, dos de ellos en posesión del servidor y el tercero de obligada presentación por parte del cliente.
						
						\begin{description}
							\item[Certificado de servidor:] Es el certificado que permite al navegador negociar el establecimiento de la conexión segura. Si se ha obtenido de algún proveedor confiable, el navagador lo gestiona de forma casi transparente al usuario. Sin embargo, si la fuente no es confiable y no se encuentra en el almacén de certificados del sistema operativo o el navegador, se muestra una advertencia al usuario aconsejándole que no continúe la navegación, aunque le permite seguir adelante a riesgo del usuario. Es lo que ocurre también cuando se utiliza un certificado autofirmado.
							
							En nuestro caso, se ha decidido utilizar un certificado autofirmado para el prototipo implementado. Los pasos necesarios tanto para crear y firmar el certificado como para configurar el servidor web para que lo utilice se pueden consultar en el anexo \ref{App:ConfiguracionServidorWeb}.
							
							\item[Certificado Raíz de la DGP:]
							
							\item[Certificado de cliente:] Para utilizar el DNIe como fuente de identificación del usuario, es preciso configurar el servidor web para que requiera en la conexión la presencia del certificado de autenticación del DNIe del usuario. Para ello, el servidor debe poseer el certificado raíz que provee la Dirección General de la Policía. Este certificado se configura en el servidor
							
						\end{description}
						
						Además de configurar el servidor para que requiera el certificado de cliente SSL, es necesario aplicar la configuración necesaria para pasar la información a la aplicación que la necesita.
						
						Para ello, el servidor web ha de exportar los datos del certificado SSL a variables de entorno.
						
						Cuando se recibe una petición al servidor, éste inyecta estas variables en la request que hace llegar al código. Concretamente, en Python (Django) son accesibles desde el META de la request. 
						
						En el siguiente código podemos ver una función que atiende una petición GET a la vista de autorización para mostrar una lista de variables asociadas a la seguridad del servidor que recibe de éste:
						
\begin{verbatim}
class AuthorizeView(View):
  form_class = AuthorizeForm
  initial = {}
  template_name = 'web/authorize.html'

  @method_decorator(validate_request)
  def dispatch(self, *args, **kwargs):
      return super(AuthorizeView, self).dispatch(*args, **kwargs)

  def get(self, request, *args, **kwargs):
      form = self.form_class(initial=self.initial)
      try:
        claves = [
            'SSL_PROTOCOL'
            ,'SSL_SESSION_RESUMED'
            ,'SSL_SECURE_RENEG'
            ,'SSL_CIPHER'
            ,'SSL_CIPHER_EXPORT'
            ,'SSL_CIPHER_USEKEYSIZE'
            ,'SSL_CIPHER_ALGKEYSIZE'
            ,'SSL_COMPRESS_METHOD'
            ,'SSL_VERSION_INTERFACE'
            ,'SSL_VERSION_LIBRARY'
            ,'SSL_CLIENT_M_VERSION'
            ,'SSL_CLIENT_M_SERIAL'
            ,'SSL_CLIENT_S_DN'
            ,'SSL_CLIENT_I_DN'
            ,'SSL_CLIENT_V_START'
            ,'SSL_CLIENT_V_END'
            ,'SSL_CLIENT_V_REMAIN'
            ,'SSL_CLIENT_A_SIG'
            ,'SSL_CLIENT_A_KEY'
            ,'SSL_CLIENT_CERT'
            ,'SSL_CLIENT_VERIFY'
            ,'SSL_SERVER_M_VERSION'
            ,'SSL_SERVER_M_SERIAL'
            ,'SSL_SERVER_S_DN'
            ,'SSL_SERVER_I_DN'
            ,'SSL_SERVER_V_START'
            ,'SSL_SERVER_V_END'
            ,'SSL_SERVER_A_SIG'
            ,'SSL_SERVER_A_KEY'
            ,'SSL_SERVER_CERT'
            ]
        for k in claves:
          try:
            logger.warn(k+': '+str(request.META[k]))
          except Exception as ex:
            logger.warn('El objeto no tiene la clave *' + k + '* --- ' + ex)

        dnie = get_dni_info_from_ssl(request)
      except Exception as e:
        logger.warn('get_No vienen las credenciales del DNIe')

      return self._render(request=request, form=form, dnie=dnie)
\end{verbatim}

					En la lista se observa una gran cantidad de variables de entorno relacionadas con la seguridad del servidor. 
					
					Aquellas que comienzan por SSL\_SERVER se refieren a la información del certificado del servidor.
					
					Por su parte, aquellas que comienzan por SSL\_CLIENT son las que contienen la información proporcionada por el certificado presentado por el cliente. En el caso de este proyecto, contendrán los datos proporcionados por el certificado de autenticación del DNIe.
					
					De estas variables, algunas son las que se utilizan para recoger la información del usuario, contrastarlo con el censo de usuarios y poder comprobar qué permisos posee, incluido el de acceso al sistema.
					
					\begin{description}
						\item[SSL\_CLIENT\_S\_DN:] Contiene la información personal del sujeto que identifica el certificado.
						\item[SSL\_CLIENT\_V\_START:] Contiene la fecha de expedicón del certificado.
						\item[SSL\_CLIENT\_V\_END:] Contiene la fecha de caducidad del certificado.
					\end{description}
				
					\item[Aplicación de autenticación]
						
						La aplicación recibe del servidor web la información del certificado del cliente a través de los METAS inyectados en el \textit{header} de la \textit{request} por parte del servidor.
						
						La aplicación implementa el flujo oAuth2 en modo Authorization Code. Con la información del usuario que recibe del certificado de cliente, lo identifica y valida los permisos que tiene.
						
						En caso de que la validación sea correcta, genera un token que almacena en la base de datos para comunicar al sistema de votación que el votante tiene permisos de acceso. Además, genera un código de autorización que devuelve al cliente. Este código lo tendrá que presentar el cliente al sistema de votación para entrar al sistema. Una vez el sistema reciba el código, lo utilizará para pedir al sistema de autenticación el token de acceso que mapea la aplicación y los permisos que dispone el usuario. Una vez el sistema de autenticación devuelve el token al de votación, éste tendrá que presentárselo para que aquel le comunique aquellos datos personales que posee del usuario que intenta acceder.
						
						Sigue, por tanto un modelo del flujo de oAuth2, apoyado en una herramienta escrita por Richard Knop en Python sobre un framework Django. No obstante, este código ha servido de base, pues ha debido ser modificado para adaptarlo a las necesidades particulares de este sistema:
						
						\begin{itemize}
						
							\item Se ha modificado el proceso de obtención de datos del usuario, pues, además de obtenerlos de la base de datos, hay que extraer información del usuario de los certificados de cliente que presenta para su identificación.

							\item Se ha modificado el sistema de validación del usuario para que contraste esta información del certificado de autenticación con el censo de la base de datos.

							\item Hay que contrastar la validez del certificado, principalmente si no ha caducado. Además, aunque al final se haya configurado en el servidor, hay que realizar una comprobación contra un servidor \gls{OCSP} para ver si ha sido revocado por la autoridad certificadora.

						\end{itemize}
						
				\end{description}
				
				
				
				
				\textbf{OCSP}
				
				El \gls{OCSP} es un servicio de revocación que ofrece la autoridad que crea el certificado raíz, en nuestro caso la DGP y la FNMT. Estas organizaciones proveen de un servicio al cual conectarse y consultar la validez de los certificados que se estén tratando de autenticar.ñ
				
				Una alternativa al OCSP es la de generar una \gls{CRL}. Las ventajas de las listas de revocación consisten en que son más simples que el \gls{OCSP} y pueden ser consultadas sin conexión a la red, lo cual es importante en caso de que el sistema esté configurado de modo que corra sobre una red privada, sin acceso a Internet (ver fifgura \ref{fig:topologiaRed_intranet} en \ref{solucion_topologiaRed}).
				
				El sistema funciona validando contra la \gls{OCSP} de la DGP. La implementación de este sistema se realiza por medio de configuración del servidor web. Es el propio servidor quien realiza la comprobación OCSP del certificado cliente y recibe la validez o no del mismo por parte del sel servicio externo.
				
				Cuando el sistema esté configurado para operar sobre una red interna será necesario desactivar esta configuración del servidor webm, pues sin acceso a Internet no será posible realizar la comprobación contra el servico de la autoridad certificadora.
				
					\subsection{Esquema de la base de datos}\label{solucion_servidor_autenticacion_bd}
					
						\begin{figure}[!ht]
							\centering
								\includegraphics[width=\textwidth]{imgs/oAuthServerER.png}
							\caption{Diagrama ER del Servidor de Autenticación}
							\label{fig:er.servidor.autenticacion}
						\end{figure}
				
								
			\section{Servidor de votación}\label{arquitectura_servidorVotacion}
			El servidor de votación es el \textit{core} del sistema. Es el que soporta toda la lógica de la elección.
			
			De cara a los administradores, permite gestionar una Elección desde su creación y definición hasta la publicación de resultados tras el escrutinio.
			
			De cara al votante, le permite acceder a la elección de las alternativas que se le presentan para votar y emitir su voto de forma segura, secreta y anónima, con la seguridad de que no es manipulado y que será correctamente escrutado.
			
			Junto al módulo central de votación, este servidor presenta otros cuatro módulos específicos.
			
			\begin{description}
				\item[Cabina de votación:] Es el módulo que permite a los votantes elegir el voto y cifrarlo. Lo separamos del módulo principal porque se un módulo escrito principalmente en javascript y se ejecuta en el navegador del cliente. Se delega en la máquina del cliente la potencia necesaria para el cifrado de su voto.
				
				\item[Verificador de la elección:] Es un módulo de acceso externo que permite, pasándole la huella digital de una elección que ya haya termiando, la verificación de la integridad de la misma. Así, por medio de funciones criptográficas, asegura que la elección ha sido correctamente escrutada y que todos los votos fueron correctamente incluídos en el escrutinio.
				
				\item[Gestor de tareas:] Utilizando la librería celery y kombu, Helios implementa un gestor de tareas basado en una cola. En el sistema se definen varias tareas que, cuando toca llevarlas a cabo, en vez de encargarse de realizarlas de forma síncrona, las incluye en una cola y sigue con el flujo de funcionamiento normal. Celery se encarga de consultar esta cola y extraer las tareas que hay que realizar. 
				
				Es el responsable de realizar tareas como la carga de ficheros de votantes del censo, iniciar el escrutinio o el envío masivo de emails a usuarios del sistema, entre otras.
				
				\item[Sistema de emails:] Hay un subsistema encargado del envío de emails a usuarios. Lo utiliza tanto el módulo central como celery para enviar emails avisando de los estados de la elección, envío del trozo correspondiente de la clave privada de la elección a los trustees, etc.
			\end{description}
			
				\subsection{Esquema de la base de datos}\label{solucion_servidor_votacion_bd}
				
					\begin{figure}[!ht]
						\centering
							\includegraphics[width=\textwidth]{imgs/HeliosER.png}
						\caption{Diagrama ER del Servidor de Votación}
						\label{fig:er.servidor.votacion}
					\end{figure}
		
		\section{Topología de la red}\label{solucion_topologiaRed}
				\todo[inline]{Para esto sí que necesito ayuda, por el tema de Firewalls y esas cosas.}
				
				De cara a la topología de la red del sistema, se ha diseñado la integración para abordar tres configuraciones diferentes dependiendo de las necesidades de la elección:
				
				\begin{enumerate}
					\item \textbf{Servidor de autenticación y Servidor de votación en la misma red. Acceso de los votantes desde Internet.} Figura \ref{fig:topologiaRed_servidoresMismaRed}
						
						Esta topología requiere port forwarding del router que comunica la red de los dos servidores con Internet para que, a través del mismo endpoint, los dispositivos se puedan conectar con los servicios de ambos servidores.
						
						Las consultas OCSP para validación del DNIe se realizan a través de Internet.
						\begin{figure}[htbp]
							\centering
								\includegraphics[width=0.30\textwidth]{imgs/topologiaRed01.jpg}
							\caption{Topología de la red con los servidores compartiendo red.}
							\label{fig:topologiaRed_servidoresMismaRed}
						\end{figure}
						
						\item \textbf{Servidor de autenticación y Servidor de Votación en redes diferentes. Acceso de los votantes desde Internet.} Figura \ref{fig:topologiaRed_servidoresDistintaRed}
						
						Esta topología no requiere port forwarding, pues cada servidor tiene su propio acceso a/por Internet. Los dispositivos accederían directamente a la IP/URL de cada servidor y utilizarían sus diferentes servicios utilizando el puerto correspondiente.
						
						Las consultas OCSP para validación del DNIe se realizan a través de Internet.
						\begin{figure}[htbp]
							\centering
								\includegraphics[width=0.30\textwidth]{imgs/topologiaRed02.jpg}
							\caption{Topología de la red con los servidores en redes diferentes.}
							\label{fig:topologiaRed_servidoresDistintaRed}
						\end{figure}
						
						\item \textbf{Tanto el Servidor de autenticación, como el Servidor de Votación y los dispositivos se comunican por la misma red, sin necesitar acceder a través de Internet.} Figura \ref{fig:topologiaRed_intranet}
						
						Haría falta un acceso a Internet para poder realizar consultas OCSP de validación del DNIe.
						
						Esta topología de red interna no cumple con los requisitos de voto e identificación remotos a través de Internet definidos en \ref{requisitosFuncionales}, pero es una buena solución para elecciones internas o para la presentación de un prototipo.
						\begin{figure}[htbp]
							\centering
								\includegraphics[width=0.30\textwidth]{imgs/topologiaRed03.jpg}
							\caption{Topología de la red con los servidores y los dispositivos en red privada.}
							\label{fig:topologiaRed_intranet}
						\end{figure}
				\end{enumerate}
				
		
			\section{Esquema de votación}\label{disenhoEsquemaVoto}
				\subsection{Registro}
					La fase de registro de votantes en el sistema no será interactivo en cuanto a que no es el propio votante el que debe inscribirse para poder votar en las elecciones, sino que es la Autoridad Electoral quien lo registra en el censo. En esta fase, pues, se trata de establecer el censo de votantes que tienen autoridad para votar en el proceso electoral.
					
					Como se advierte en el análisis se ha tomado en consideración que sean los administradores del sistema quienes tengan responsabilidad sobre el tratamiento del censo, por lo que se ha de cargar en el sistema y éste es el que lo va a tratar.
					
					El censo ha de cargarse en dos servicios del sistema, tanto en el servidor de autenticación como en el sistema de votación.
					
					El censo del subsistema de autenticación se utilizará para llevar el control de los votantes que tienen derecho de acceso al sistema, por lo que a los votantes se les pueden añadir otros usuarios necesarios para llevar a término la votación, como pueden ser administradores o auditores, aunque estos no tengan derecho de voto. Así se conformaría la base de usuarios activos del sistema.
					
					En el subsistema de voto también se vuelca el censo para cada uno de los diferentes procesos de voto que conformen la elección.
					
					El procedimiento a seguir consistirá en que la Autoridad Organizadora del Proceso Electoral, la Universidad, proveerá una lista del censo a los administradores del sistema. El administrador utilizará la función de carga de votantes con la lista proporcionada para realizar la carga inicial de votantes para cada una de las subelecciones que se configuren.
					
					La lista proporcionada por la Universidad debe contener la siguiente información de cada uno de los votantes:
						\begin{itemize}
							\item Nombre y apellidos
							\item DNI
							\item Clase / grupo de votantes
							\item E-mail
						\end{itemize}
						
					La carga de los votantes a través de su aplicación se realiza subiendo un fichero csv con la información requerida. Este fichero se pone a disposición de la cola de procesos, la cual, llegado el momento volcará cada uno de los registros en la base de datos del sistema de votación.
					
					\notasDuda{Falta definir el proceso de carga de votantes para el servicio de autenticación.}
					
				\subsection{Identificación / Autenticación}
					El servicio de identificación es un subsistema clave en el proceso electoral. En él recae parte de la responsabilidad de la robustez del sistema, en cuanto a que debe asegurar varios de los requisitos básicos que definen el voto electrónico en concreto:
					
		\notasInfo[inline]{Esto es así según los requisitos de Fujioka, si se utilizan los de la UNEX, se puede modificar.}
		\begin{description}
			\item[Solidez:] Debe asegurar que un votante deshonesto no tenga capacidad de acceder al sistema e interrumpir la votación. Es decir, que sólo debe dar acceso a los votantes que realmente deben ingresar al sistema de votación.
			
			\item[Elegibilidad:] Este requisito implica que el sistema debe controlar que ningún votante que no tenga permitido el voto pueda votar. Aunque es el proceso de votación el que debe controlar esta circunstancia cuando un usuario trata de emitir un voto, el sistema de votación, de forma análoga al requisito anterior, también debe proteger el sistema evitando el acceso a aquellos que, directamente, no tengan permisos para votar.
			
			\item[Sin duplicados:] El sistema debe evitar que un votante duplique o reemplace el voto de otro. Igualmente, aunque es el sistema de votación el que debe tener mecanismos que controlen esta situación, la primera barrera debe ser la servicio de autenticación del votante.
			
		\end{description}

					
			 El sistema de identificación del votante se apoya en el protocolo oAuth2.
			\notasInfo[inline]{Aquí desarrollamos la implementación oAuth que hemos desarrollado para este sistema}
			Como ya se ha comentado, el sistema de identificación/autenticación federada que se va a utilizar se basa en un proyecto publicado como software libre por el desarrollador Richard Knop con nombre django-oauth2-server.
			
			Este servidor está escrito en Python y se ha desarrollado sobre el framework Django, el mismo sobre el que está desarrollado el propio sistema de votación, Helios Voting.
			
			El servidor, tal como está desarrollado no sirve para las necesidades del proyecto, pues no soporta certificados digitales.
			
			El primer paso para la implementación del servidor consiste en configurar el framework Django para que se apoye en un servidor web externo. Para este proyecto se ha utilizado el servidor web Apache.
			
			Es necesario instalar dos módulos específicos:
			
			\begin{description}[font=$\bullet$\scshape\bfseries]
				\item[mod\_wsgi]: Módulo que permite que una aplicación basada en Django corra sobre un servidor web externo, como Apache.
				\item[mod\_ssl]: Módulo que permite a ciertos servidores web utilizar certificados digitales como forma de autenticación. En el caso de nuestro proyecto, servirán tanto para establecer los canales SSL/TLS como para incluir el certificado digital de autenticación del DNIe en el canal seguro, recuperar la información de usuario del certificado y pasarla al código del servidor.
			\end{description}
					
					
					\begin{figure}[!ht]
						\centering
							\includegraphics[width=.95\textwidth]{imgs/flujoOAuth.jpg}
						\caption{Flujo oAuth para servicio de autenticación}
						\label{fig:flujo.oauth}
					\end{figure}
					
					
					
					
					
					\subsubsection{App Android de Autenticación}\label{solucion_appAndroidAutenticacion}
					Ya se ha explicado que para realizar el acceso al sistema de voto desde dispositivos móviles, se ha optado por modificar una de las apps de ejemplo publicadas por la Policía española.
					
					La app original mostraba un ejemplo de funcionamiento en el que se accedía a varias webs que necesitaban acceso con identificación por DNIe. Las modificaciones que se han realizado a esta app han consistido en:
					\begin{itemize}
						\item Eliminar el menú inicial con el que se podía elegir el servicio al que se pretendía acceder.
						\item La app ahora sólo tiene una funcionalidad, conectarse contra el servidor de autenticación de nuestro sistema de votación.
						\item Para ello, se ha modificado el software cambiando el flujo de llamadas. Originalmente sólo se hacía una llamada a una web para obtener información. Para cumplir con el protocolo oAuth, se ha incrementado el número de llamadas HTTPS de la app, con una mayor comunicación bidireccional entre el servicio y el dispositivo.
						\item La app embebe keystore con los certificados de servidor y el raíz de la Policía para cada uno de los servicios que utiliza. Se han eliminado y se ha incorporado una keystore con los certificados del servidor de autenticación y el de la AC raíz de la Policía.
						\item La app posee una lista de servidores en los que confía. En esta lista se incluyen los hashes de los certificados de servidor de los servicios que consulta. Se han eliminado los elementos de esta lista y se ha añadido el hash del certificado del servidor de autenticación, que es contra el que ahora se va a comunicar la app.
						\item En la app original, se realiza una llamada HTTPS, se obtiene la información y se muestra en una página estática dentro de un WebView. Los WebViews en Android no soportan navegación manteniendo certificado de cliente, por lo que no es útil para la nueva funcionalidad de nuestra app. Por ello, se ha eliminado esta forma de mostrar información. Ahora se realizan las comunicaciones del flujo oAuth y cuando el usuario ha sido identificado y autenticado, se redirige a la web del sistema de voto por medio de un navegador externo a la app.
					\end{itemize}
					
					La comunicación puede comenzar de dos formas:
					\begin{enumerate}
						\item El usuario entra con un navegador móvil en la web de la elección (figura \ref{fig:login.android.navegador}). Esta le muestra un link para realizar el login seguro a la misma. El sistema de voto identifica con Javascript que el usuario accede desde un dispositivo Android, con lo que modifica el link para que se ejecute un intent, la intención de abrir una app en el dispositivo, en lugar de redirigirse a una web.
						Este link modificado se corresponde con 
						\begin{verbatim}
						intent://scan/#Intent;scheme=dnie;package=com.dnieadmin;end
						\end{verbatim}
						
						En este enlace, \textit{scheme=dnie} y \textit{package=com.dnieadmin} son valores definidos en el AndroidManifest.xml del proyecto. Al utilizar el protocolo \textit{intent://} se indica al dispositivo que se está \textit{intentando} utilizar una aplicación.
						
						 Si la app se encuentra instalada, se abrirá. En caso contrario, se dirige al usuario a la Play Store de Google para que se descargue la app.
						\begin{figure}[!h]
							\centering
								\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_020.png}}
							\caption{Página de inicio en navegador de dispositivo Android.}
							\label{fig:login.android.navegador}
						\end{figure}
						
						\item Directamente, el usuario entra en la app desde el menú de aplicaciones (figura \ref{fig:login.android.menu}) del Launcher del Sistema Operativo.
						
						\begin{figure}[h!]
							\centering
								\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_010.png}}
							\caption{Menú de aplicaciones de dispositivo Android}
							\label{fig:login.android.menu}
						\end{figure}
					
					\end{enumerate}
					
					
					En este momento, cualquiera que sea el camino que se ha seguido, el usuario entra en la app. Con respecto a la app original, se ha eliminado el menú principal y todas las funcionalidades que aportaba. Directamente, se muestra la pantalla de introducción o selección del \gls{CAN} (figura \ref{fig:login.android.seleccionCANvacio}). El \gls{CAN} es un identificador de 6 dígitos que aparece en el anverso del documento físico del \gls{DNIe}. Se utiliza para establecer un canal cifrado \gls{PACE} entre el documento y el dispositivo.
					
					\begin{figure}[!ht]
						\centering
							\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_030.png}}
						\caption{App Autenticación Android: Selección del CAN cuando no hay ningún documento guardado previamente.}
						\label{fig:login.android.seleccionCANvacio}
					\end{figure}
					
					Este canal \gls{PACE} es obligatorio a la hora de establecer una conexión inalámbrica cifrada, pero no sustituye al \gls{PIN} en ningún caso, igual que no da permiso de uso de las claves de autenticación y/o firma del ciudadano. Es una herramienta más de seguridad para evitar que un tercero pueda leer información del DNIe sin conocimiento del ciudadano dueño del documento.
					
					\begin{figure}[!ht]
						\centering
							\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_035.png}}
						\caption{App Autenticación Android: Pantalla para introducir el CAN.}
						\label{fig:login.android.introducirCAN}
					\end{figure}
					
					Una vez introducido el \gls{CAN} por primera vez, ya no será necesario volver a hacerlo, ya que se almacena en el sistema y puede seleccionarse el apropiado cada vez que el usuario hace uso de la aplicación. Al igual que se pueden guardar más documentos, es posible eliminar el \gls{CAN} de documentos ya introducidos. (figura \ref{fig:login.android.seleccionCAN})
					
					\begin{figure}[!ht]
						\centering
							\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_040.png}}
						\caption{App Autenticación Android: Selección del CAN.}
						\label{fig:login.android.seleccionCAN}
					\end{figure}
					
					En caso de intentar una lectura de la información de un \gls{DNIe} introduciendo un \gls{CAN} incorrecto se produciría un error al establecer el canal \gls{PACE} y no sería posible la comunicación entre documento y dispositivo (figura \ref{fig:login.android.seleccionCANvacio}).
					
					\begin{figure}[!ht]
						\centering
							\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_036.png}}
						\caption{App Autenticación Android: Error al introducir un CAN incorrecto.}
						\label{fig:login.android.seleccionCANvacio}
					\end{figure}
					
					Cuando se ha indicado el \gls{CAN} correcto del documento que se va a utilizar para logarse en el sistema, la aplicación solicita al usuario que acerque su documento físico al dispositivo para que este pueda acceder a los certificados (figura \ref{fig:login.android.aproximeDNIe}).
					
					\begin{figure}[!ht]
						\centering
							\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_050.png}}
						\caption{App Autenticación Android: Esperando que se aproxime el DNIe 3.0.}
						\label{fig:login.android.aproximeDNIe}
					\end{figure}
					
					La comunicación entre documento y dispositivo se realiza mediante \gls{NFC} (\ref{estadoNFC}). Según el documento \cite{dnieAutenticacion:1.0}, los desarrolladores de la app de ejemplo indican que \textit{''por motivos de hardware y de seguridad, la distancia máxima soportada por NFC es, dependiendo del dispositivo, de alrededor de un centímetro''}. De todos modos, es una comunicación ciertamente sensible, que se ve afectada por la distancia y el movimiento, necesitando para un correcto funcionamiento cercanía y una notable estabilidad.
					
					
					Una vez estén cerca documento y dispositivo, se detectarán y establecerán la comunicación cifrada entre ambos (figura \ref{fig:login.android.cargandoCertificados}), a través de la cual podrán intercambiarse tanto comandos como respuestas a estos, accediendo a la información alojada en los certificados y permitiendo a estos firmar información presentada por el dispositivo (aunque en nuestra app no hará falta utilizar el certificado de firma digital).
					
					
					\begin{figure}[!ht]
						\centering
							\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_060.png}}
						\caption{App Autenticación Android: Cargando certificados.}
						\label{fig:login.android.cargandoCertificados}
					\end{figure}
					
					
					Para poder llegar a utilizar los certificados, no obstante, primero se solicitará el \gls{PIN} al usuario (figura \ref{fig:login.android.DNIe.PIN}), con el cual se autentica al mismo contra el DNIe y se le conceden permiso de acceso a las claves. A partir de este momento, la comunicación entre documento y dispositivo va cifrada y se pueden acceder a los certificados.
					
					\begin{figure}[!ht]
						\begin{subfigure}{.5\textwidth}
							\centering
								\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_070.png}}
							\label{fig:login.android.introducirPIN}
						\end{subfigure}
						\begin{subfigure}{.5\textwidth}
							\centering
								\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_080.png}}
							\label{fig:login.android.PINintroducido}
						\end{subfigure}
						\caption{App Autenticación Android: Introducción del PIN del DNIe 3.0}
						\label{fig:login.android.DNIe.PIN}
					\end{figure}
					
					Es en este momento cuando la app utiliza el certificado de autenticación del DNIe realizar una petición HTTPS/TLS contra el servidor de autenticación del sistema de voto. Cada una de las llamadas que le exige el protocolo de comunicación oAuth2 se realizará de forma segura, con los certificados del servidor y el de autenticación del documento (figuras \ref{fig:login.android.lanzandoConexion} y \ref{fig:login.android.recepcionCodigooAuth}). 
					
					\begin{figure}[!ht]
						\centering
							\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_090.png}}
						\caption{App Autenticación Android: Lanzando conexión segura con los certificados.}
						\label{fig:login.android.lanzandoConexion}
					\end{figure}
					
					\begin{figure}[!ht]
						\centering
							\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_100.png}}
						\caption{App Autenticación Android: Recepción de código oAuth.}
						\label{fig:login.android.recepcionCodigooAuth}
					\end{figure}
					
					Para poder establecer un canal seguro contra el servidor de autenticación, es necesario, según la implementación de la app original de ejemplo, que el certificado del servidor y la AC raíz vayan embebidos en el código de la app. Así mismo, es necesario que se incluya el hash del mismo para que el objeto DroidHTTPClient que establece la conexión al servidor sea capaz de establecer este camino seguro.
					
					Esta keystore con los dos cerrtificados se debe incluir en el proyecto Android con un formato BKS, lo cual se consigue realizando los pasos expuestos en el anexo \ref{App:exportarCertsAppAndroid}.
					
					Una vez obtenido el fichero keystore que contiene los dos ceritficados, ha de colocarse en la carpeta del proyecto:
					
					\small\begin{verbatim}
					clienteAndroidDNIeoAuth2/app/src/main/res/raw
					\end{verbatim}
					
					Para añadir el hash del certificado del servidor habrá que editar también el fichero:
					
					\small\begin{verbatim}
					clienteAndroidDNIeoAuth2/app/src/main/res/values/trusted_hosts.xml
					\end{verbatim}
					
					Este hash se obtiene en el servidor con el comando que se indica igualmente en el anexo \ref{App:exportarCertsAppAndroid}.
					
					Así, el fichero que indica qué servidores son confiables y que utiliza la app para poder establecer una conexión segura con el servidor quedaría parecido a este:
					
					
					\small\begin{verbatim}
<resources xmlns:android="http://schemas.android.com/apk/res/android">
  <array name="trusted_hosts">
    <item>D5E6E3759023DE9B881399DC034E8FE1AE7D9D87</item> 
    <!-- En el servidor: openssl x509 -fingerprint -noout -in server.crt -->
  </array>
</resources>
					\end{verbatim}
					
					El servidor de autenticación establece un canal seguro con su certificado (en el prototipo será autofirmado) pero valida el certificado de autenticación con el certificado AC Raíz de la Policía que posee y que se ha configurado para ser utilizado. Por esta razón aparece un error en el navegador cuando se entra por primera vez a la web (figura \ref{fig:login.android.certAutofirmado}). Avisa al usuario de que no encuentra en su almacén de certificados uno que sea confiable con el servidor. En nuestro caso, para el prototipo, bastará con hacer click en \textit{CANCELAR} ya que no vamos a instalar certificados adicionales. En caso de implementar el sistema en producción, será necesario obtener e instalar en el servidor un certificado confiable, emitido por una autoridad de confianza.
					
					
					\begin{figure}[!ht]
						\centering
							\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_105.png}}
						\caption{App Autenticación Android: Los certificados autofirmados no son seguros, pero la comunicación va cifrada de todos modos.}
						\label{fig:login.android.certAutofirmado}
					\end{figure}
					
					Una vez asumimos el certificado autofirmado, por fin accedemos a la web del sistema de voto logados con la información contenida en el certificado de autenticación de nuestro DNIe 3.0 (figura \ref{fig:login.android.logado}).
					
					\begin{figure}[!ht]
						\begin{subfigure}{.5\textwidth}
							\centering
								\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_110.png}}
							\label{fig:login.android.logado01}
						\end{subfigure}
						\begin{subfigure}{.5\textwidth}
							\centering
								\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{.2px}\fbox{\includegraphics[height=6cm]{imgs/login_Android/android_120.png}}
							\label{fig:login.android.logado02}
						\end{subfigure}
						\caption{App Autenticación Android: Acceso al sistema de voto con login con el DNIe.}
						\label{fig:login.android.logado}
					\end{figure}
					
				\subsection{Definición de la papeleta}\label{solucion_definicionPapeleta}
					El principal cambio que se ha implementado en la tarea de definición de las opciones de la papeleta ha sido el de añadir automáticamente la opción del voto en blanco a la papeleta.
					
					Ahora, cada vez que un administrador cree una consulta en una papeleta, junto con las opciones que defina, automáticamente se adjuntará la opción del voto en blanco.
					
					Esta modificación trata de satisfacer el requisito \ref{reqEspecificos_blancos} definido entre los requisitos específicos (\ref{requisitosEspecificos}).
					
					
				\subsection{Elección de candidatura}
				\subsection{Votación}
				\subsection{Escrutinio}
				\subsection{Difusión de resultados}
				
				
			\section{Diseño de la capa de datos}
				\todo[inline]{Al hablar de Helios ya se puso un diagrama de datos. Repetir destacando los cambios. Añadir el diagrama E-R del servidor de oAuth}
			
			
				
			\section{Diseño de la app de identificación}
			Para la identificación utilizando un dispositivo móvil se va a implementar una herramienta que hace uso de la tecnología NFC para leer el chip de autenticación del DNIe del votante y comunicar a este usuario con el sistema de votación utilizándolo como mecanismo de identificación y autenticación.
			
			La base de este desarrollo es la app de Autenticación implementada por la Policía como ejemplo de desarrollo que se puede realizar con Android para hacer uso del chip NFC del DNIe 3.0.
			
			Hay varios elementos que han debido modificarse con respecto a la app original.
			
			\subsection{Código fuente}\label{solucion_app_codigofuente}
			Obviamente, el código fuente de la app ha debido ser modificado ya que la funcionalidad que se busca que tenga la aplicación no es la misma que la que ofrece la original.
			
			En la app original, al entrar se nos ofrece un menú radial con diferentes opciones. Esto no ocurre en la versión de este proyecto. La app en nuestro caso está pensada para realizar tan sólo un trabajo, realizar la identificación y autenticación de usuario contra un servidor oAuth y transmitir al sistema de votación la aceptación o revocación de acceso del mismo contra el sistema.
			
			Por ello, la app va a carecer de un menú inicial, ya que no es necesario.
			
			Una vez se abra la app, ya sea desde el menú del dispositivo o desde el botón de login de la página inicial de la web del sistema de votación, aparecerá el menú de selección del CAN del DNIe que queremos utilizar, o, si es la primera vez que cierto usuario utiliza la app, la posibilidad de añadir un nuevo DNIe con su CAN correspondiente.
			
			
			\todo[inline]{¡¡ Comentado ya en el apartado \ref{solucion_appAndroidAutenticacion} !!}
			
							
			\section{Diseño de la interfaz de usuario}\label{diseño_interfaz_usuario}
				Se ha realizado una renovación de la interfaz de usuario del sistema original Helios. La interfaz original, si bien no tenía grandes problemas de visualización, ha resultado no adaptarse correctamente a los dispositivos móviles, con pantallas de menor tamaño y una forma diferente de ser utilizadas, ya que los usuarios suelen interactuar con diferentes hábitos al visitar la misma página web desde un dispositivo de escritorio o uno móvil.
				
				Las modificaciones más importantes se han realizado sobre la estructura de construcción de las páginas y sobre el estilo que en ellas aplica.
				
				Se ha intentado que las páginas cumplan con el estándar W3C y con reglas básicas de accesibilidad.
				
				Para la interfaz de usuario hay varias necesidades que se han debido de satisfacer.
				
				Por un lado, la imagen corporativa. Al tratarse de un proceso electoral diseñado para una entidad, la plataforma en la que se basa debería mostrar inequívocamente la imagen de la entidad que lo organiza.
				
				Otro aspecto a tener en cuenta será la adaptación a dispositivos móviles, pues lo que se busca es el voto seguro desde este tipo de dispositivos, algo que no cubre con suficiencia la versión actual de Helios Voting.
				
				\subsection{Estructura de la página web}
					\todo[inline]{Cambios en la interfaz original de Helios. Responsive....}
					El principal reto en cuanto a las modificaciones necesarias en la interfaz del sistema original Helios han correspondido a convertir las páginas en \textit{responsive}. Con ello, lo que se busca es adaptar la visualización de las diferentes páginas en distintos dispostivos, con diferentes recursos y distintos tamaños de pantalla, así como la capacidad de adaptarse, en un mismo dispositivo, a una situación en la que la pantalla se observa en vertical y se gira a horizontal o viceversa.
					
					Para llevar a cabo esta tarea, nos hemos centrado en las hojas de estilo existentes a las cuales se le han realizado modificaciones. Principalmente, se han incluido reglas que aplican dependiendo del ancho de la pantalla que 
					
				\subsection{Estructura de la aplicación móvil}
					\todo[inline]{Interfaz de usuario de la app.}
					La interfaz de usuario de la app Android necesaria para ingresar en el sistema con los certificados deigitales del DNIe 3.0 no ha sido modificada ostensiblemente.
					
					Aunque es una parte primordial del sistema y su adaptación ha requerido bastante estudio y desarrollo, realmente al final no se utiliza durante un tiempo suficiente. Por ello, para el prototipo se ha decidido no invertir demasiado tiempo en su modificación estética, por lo que se ha reutilizado la diseñada originariamente por los desarrolladores de la app original de la DGP.
					
				\subsection{Accesibilidad}
					\todo[inline]{Destacar accesibilidad}
\iffalse					
				\subsection{Imagen corporativa}
					\todo[inline]{Como imagen de marca, bla bla bla, al no haber un logo del proceso, bla bla bla, se puede introducir uno o utilizar el de la Universidad, bla bla}
					La interfaz de Helios Voting se corresponde con un sistema neutro para realizar elecciones en la plataforma web de ejemplo que tienen publicada junto con el código fuente del proyecto.
					
					Esta interfaz está bien para el propósito que tiene el sistema original, que es, por un lado, mostrar un ejemplo de funcionamiento del proyecto y, por otro, dar una herramienta funcional para la realización de pequeños procesos electorales seguros por Internet para grupos reducidos que no necesiten una implementación propia.
					
					A la hora de utilizar esta herramienta para montar un sistema electoral propio, en infraestructuras de un cliente, esta interfaz no se corresponde con la que debería tener un proyecto diseñado para dicho clienta.
					
					Cualquier proceso electoral suele y debe tener una imagen corporativa propia que pueda identificarse claramente con el propio proceso y con las autoridades que lo organizan, con la finalidad de que el votante identifique claramente el origen del proceso y no dé lugar a equívocos, además de que, en cierto modo, aumentan la seguridad del mismo en el proceso.
					
					La Universidad no parece tener publicada una imagen de marca, con reglas y recomendaciones que definan el estilo que deben tener aquellas webs y documentos que se desarrollen o publiquen en su nombre. No obstante, se observa en su web que sí la tiene. Ya sea en los colores utilizados, en el diseño del logo y en la definición de los documentos publicados en su web.
					
					Por ello, se observa necesario implementar una imagen en el sistema que se corresponda con la Universidad. Al no publicar esta unas guías de imagen de marca, lo correcto será proponer un diseño de los sistemas inspirado en los que utiliza actualmente la Universidad en su web oficial o en los documentos que publica. El fin de este diseño integral adecuado será ayudar al usuario a identificar el organizador del proceso electoral, al mismo tiempo que simplifique el proceso de votación, o al menos, no lo complique.
					
					Utilizando como base la interfaz actual del proyecto Helios se le realizará una serie de modificaciones para realizar este cambio de marca.
					
					Por un lado, junto al logo de la Universidad, es conveniente diseñar un logo que represente la Elección. Esto dota al proceso de una imagen propia, aunque asociada a la entidad organizadora, con la que se trata de transmitir la importancia y seriedad del Proceso al usuario.
					
					La elección del juego de colores de los sistemas, tanto de las webs de los sistemas de Identificación y Voto como de la app de Android se basará en los colores de la web actual de la Universidad San Pablo CEU. La estructura de las páginas webs del sistema, no obstante, no será similar a la de la Universidad, ya que tratan información diferente y ésta no es adecuada para el flujo del usuario en el sistema de votación.
					
					Para el prototipo a implemetar se ha decidio, no obstante, utilizar la gama de colores que ofrece la librería Bootstrap, sin tener en cuenta estas reglas de marca.
					
					
					\notasInfo[inline]{Dar una muestra de colores y de logos de la elección}
					
					\begin{figure}[!ht]
						\centering
							\includegraphics[width=.5\textwidth]{imgs/logo_usp_ceu.jpg}
						\caption{Logo de la Universidad San Pablo CEU en su web}
						\label{fig:logo.universidad_san_pablo_ceu}
					\end{figure}
				
				
					\notasInfo[inline]{Colores...accesibilidad!}				
				
				Uno de los requisitos que debe cumplir un sistema de votación es que sea accesible para el mayor número de personas posible. Desde el punto de vista de la interfaz esto implica que:
				\begin{itemize}
					\item Debe funcionar correctamente en la mayoría de los navegadores web.
					\item Debe cumplir con los estándares de accesibilidad (WCAG, AA+)
					\item La web debe cumplir con el estándar del consorcio W3C.
					\item La información presentada debe cumplir con la internacionalización (i18n) necesaria para llegar al mayor número posible del censo y de los observadores.
				\end{itemize}
				
\fi
				
				
				
				
\iffalse				
				\todo[inline]{Desde aquí hasta el comienzo de \ref{solucion_protocolo} hay que moverlo a Análisis.}
				En varios de los sistemas estudiados que se han desarrollado para intentar implantar el voto electrónico a un nivel medio, como pueden ser los mexicanos SELES \ref{seles} y SEVI \ref{sevi} o los españoles de Víctor Moreno \cite{moreno07} \notasDuda{???????}o Votescript \ref{ivotingVotescript}\notasDuda{???????} se observa que se realiza una división del proceso electoral en cuatro fases (Registro, Votación, Consolidación de resultados y Auditoría). En el desarrollo de este sistema vamos a identificar las mismas fases, pero con matices.
				
				Así, en una primera visión global del sistema, en este se definen cuatro fases:
				\begin{itemize}
					\item Preelectoral
					\item Votación
					\item Consolidación de resultados
					\item Postelectoral
				\end{itemize}
				
				Realmente, la mayor diferencia con las fases definidas en los esquemas anteriores se corresponden con el alcance de la primera y la última fase.
				La fase Preelectoral, denominada comúnmente en los ejemplos estudiados en la Introducción como fase de Registro, en este sistema tiene un alcance mayor. En este proceso electoral no se requiere que el votante se registre para poder votar. El censo lo proporciona la Autoridad Electoral y se carga en el sistema. Igualmente, en los días previos a la jornada electoral el sistema permitirá a los votantes comprobar si están en el censo y qué información contiene éste, tanto personal - para asegurarse de que podrán identificarse - como de permisos de cara a realizar la votación.
				
				
				
				Las fase de Votación también tiene un alcance diferente. En primer lugar, empieza con la identificación del votante en el sistema electoral. Una vez el votante ha sido correctamente identificado por el sistema (tal como lo haría contra los miembros de la mesa en el voto tradicional), debe recibir una boleta electrónica que le ofrezca las opciones entre las que, por su circunscripción, deba elegir la que desea votar. Una vez seleccionado, es el momento en el que realmente el votante realiza la votación, traspasando el voto de forma digital al sistema, a la \textit{urna digital} donde se anonimizarán y almacenarán hasta la fase de consolidación.
				
				En la fase de consolidación de resultados, el sistema se encargará del conteo de los votos que han sido emitidos
				\todo[inline]{continuar...}
				
				La fase Postelectoral, que denominan Auditoría, prefiero dejarla con este nombre, ya que considero que la auditoría del sistema es una operativa que se realiza durante toda la jornada electoral, no sólo al finalizar ésta. No obstante, es cierto que al final se llevarán a cabo auditorías de los resultados y el funcionamiento. Además de las auditorías llevadas a cabo por los auditores \textit{oficiales}, se va a implementar un mecanismo que permita a los propios votante auditar que su voto ha sido correctamente incluido y contado en el proceso. Esta fase postelectoral también tiene más pasos ... \todo[inline]{continuar con fase postelectoral}
				
			\todo[inline]{Antes de este punto hay que hacer un resumen de los diferentes esquemas de votación, teniendo estos como Firma ciega, mixnets, etc...}
\fi

\iffalse
			\subsection{Protocolo}\label{solucion_protocolo}
			\textst{
				Como se ha comentado en capítulos anteriores, hay una multitud de soluciones propuestas para el voto telemático.
				
				Teniendo en cuenta el objetivo de este Proyecto Fin de Carrera, de los sistemas implementados a gran escala, a nivel nacional o regional, podemos destacar Estonia, Noruega y los cantones suizos como las tres experiencias más exitosas y aquellas de las que se pueden estudiar las soluciones, esquemas y protocolos utilizados. No obstante, el alcance de las mismas supera sobremanera el de este proyecto. Igualmente, muchas decisiones las toman en base a satisfacer requisitos que resultan muy importantes en su análisis, pero que en este trabajo no se ha considerado que tengan igual trascendencia, y viceversa, por lo que se han de tomar diferentes consideraciones frente a los mismos problemas dependiendo del impacto que suponen en cada proyecto.
				}
				También se han presentado casos de proyectos de voto telemático pensados a menor escala. Entre ellos, hay muchas soluciones que, en parte, podrían satisfacer los requisitos de este proyecto. No obstante en ninguno de ellos encontramos un protocolo que se adapte completamente a los requerimientos planteados, ya que, en algún momento, se analiza un elemento que los hace diferir. Por ejemplo, un proyecto ya maduro como Votescript (\ref{ivotingVotescript}) realiza un estudio académico y técnico muy profundo acerca del voto telemático pero, por su propia definición, el modelo de identificación y emisión del voto lo sitúan físicamente en centros de votación. Este elemento es diferencial para este proyecto, pensado en el voto telemático remoto, aunque puede integrarse cuando se estudian alternativas para que aquellos votantes que, por algún motivo, no pueden o quieren votar por Internet de forma remota tengan la oportunidad de ejercer su derecho de sufragio desde un lugar habilitado para ello por la propia Escuela.
				\textst{
				A partir de los esquemas criptográficos estudiados y con ayuda de algunos protocolos ya publicados en otros proyectos, el siguiente paso es diseñar el protocolo de votación que se adapte a las necesidades del Proyecto, cumpliendo con los requisitos y asegurando los niveles de seguridad planteados.
				
				En muchas de las soluciones estudiadas se observa que no recibe la importancia necesaria la fase de identificación del votante. Los mecanismos de identificación y autenticación del mismo resultan laxos desde el punto de vista de la seguridad ante el fraude electoral. Por ello han sido descartadas las soluciones basadas en identificación por medio de bases de datos con el típico protocolo de usuario/contraseña o incluso con elementos de seguridad de una generación algo posterior, como pin, patrones, captchas, operaciones aritméticas o métodos similares con mayor o menor complejidad. Igualmente, se han descartado aquellos métodos de identificación que requieran la presencia física del votante frente a los responsables de la mesa de votación, ya que se busca el diseño de un sistema remoto. Así descartamos protocolos de identificación como los publicados por Votescript, en el que el votante acude a un centro o local de votación, se identifica ante la mesa electoral y recibe un token criptográfico personalizado con el que se le permite ejercer el sufragio.
				
				La mayoría de las soluciones estudiadas previamente a la realización de esta memoria centran sus esfuerzos en la fase de votación. Buscan la elaboración de un protocolo robusto, basado en esquemas criptográficos, que permita la mayor seguridad posible al cumplimiento de los requisitos fundamentales del voto electrónico, dotando al sistema de privacidad del votante, 
			}
				\todo[inline]{Hay que modificarlo. Es anterior a la decisión de utilizar Helios}
\fi				
				
				
				
				
				
				
				
				
				
				
				
				
				
				%\subsubsection{Descripción del sistema}\label{solucion_descripcion}
				%El sistema contará de cinco fases, determinadas por el flujo temporal de la votación.
				%Preelectoral, Identificación, Votación, Escrutinio y publicación de resultados.
				%Adicionalmente, se tendrá en cuenta un sistema de auditoría, de carácter transversal a este flujo, ya que debe estar disponible durante todo el proceso de votación.
				%
				%\todo[inline]{No he podido conseguir reglamentación oficial de la elección, así que, básicamente, propongo yo las fases y la problemática ... esto, con palabras aquí escrito y bien puesto }
				%
				
\iffalse
				\section{ESTO ES EL PFC}
				\todo[inline]{ESTO NO VA EN EL PFC, ES UNA EXPLICACIÓN PARA TENER PRESENTE QUÉ ES EL PFC YU PODER DESARROLLAR LA MEMORIA EN TORNO A LA IDEA QUE TENEMOS.}
				El sistema que se propone en este PFC es un sistema integral. Busca sostener el proceso electoral desde el comienzo hasta el final del mismo. Por ello empieza en el momento mismo de definición del censo y no termina hasta que la publicación de resultados y su auditoría son oficializadas por el órgano rector de la Elección.
				
				La primera fase, preelectoral, es aquella previa al día electoral, en la cual se definen las bases en las que se rige el proceso electoral.
				
				Así, es imprescindible cumplimentar varias acciones por parte de los desarrolladores, administradores y órgano electoral.
				
				En primer lugar, es fundamental la elaboración de un censo electoral. En éste se recogen los potenciales votantes, aquellos con derecho a voto, identificando, además, la circunscripción \notasDuda{Cir-cuns-crip-ción??? No hay una forma mejor de expresarlo??} a la que pertenece. En unas elecciones legislativas, una circunscripción electoral se puede definir como el conjunto de electores a partir del cual se procede la distribución de los escaños asignados, en función de la distribución del los votos sufragados. En las elecciones legislativas españolas, las circunscripciones se corresponden con las provincias españolas (excepto en el caso de Aturias, que está subdividida en 3 distritos electorales, y la Región de Murcia, que lo hace en 5). Esto significa que del total de diputados que se eligen en este proceso para la totalidad de España, en vez de repartirlos con el recuento total de los votos, se reparten los cargos por cada circunscripción, dependiendo del número de electores de cada una, con lo que los votantes censados en una circunscripción, digamos por ejemplo la provincia de Málaga, elegirán a un número determinado de diputados que serán quienes les representen en el Congreso junto a los elegidos en el resto de territorios españoles. En las Elecciones al Parlamento Europeo, sin embargo, España actúa como una única circunscripción, por lo que los diputados que representarán al país en la cámara supranacional se obtendrán a base de repartir los escaños con respecto al total de votos recogidos en todo el territorio español.
				
				Algo parecido es lo que se va a definir en el censo electoral. Además de recoger de forma unívoca a los electores con derecho al voto, se tendrán que sumar las ************\notasCambio{*********} necesarias para su correcta identificación, así como la ``circunscripción'' a la que pertenece, es decir, el grupo sobre el que debe escoger a sus representantes, con el fin de que la opción de voto que el sistema le presente y la que introduzca en el sistema sea correcta.
				
				Se vislumbran aquí dos requisitos del voto electrónico que necesitan ser satisfechos para la integridad del proceso electoral.
				
				En primer lugar, es básico que el censo defina claramente los votantes con derecho al voto y provea de la información necesaria para que se pueda comprobar la identidad del votante en el momento en el que se disponga a votar. En las elecciones con voto tradicional esto se conseguía añadiendo datos personales tales como el número del DNI, del Pasaporte o, en caso de estas elecciones, el número de identificación del alumno. Así, al acudir a la mesa electoral todos los votantes tenían estos datos con los que se podían identificar frente a los miembros de la misma, los cuales tienen la potestad de permitirles votar o no.
				
				Integridad del voto. El hecho de relacionar cada votante con una ``circunscripción'' es esencial a la hora de mantener la integridad de la votación, pues hay que tener en cuenta los candidatos a los que cada votante puede votar, ya que no son los mismos para todos. Igual que en unas legislativas españolas un votante de Málaga no elige entre los mismos candidatos que lo hace un votante de Lugo, en estas elecciones, un alumno elige sus representantes entre los delegados de curso, mientras que los profesores, por su parte, lo hacen entre otros colegas profesores. Es indispensable, pues, gestionar correctamente estas relaciones ya que no se deben recoger votos de votantes a candidatos a los que no tiene derecho a elegir.
				
				En el caso de esta elección, es la propia Escuela Politécnica Superior la que debe proveer el censo oficial a los administradores del sistema, los cuales procederán a cargarlo en el mismo a través de los mecanismos implementados para ello.
				\notasInfo[inline]{(Aquí encontramos un primer punto de auditoría importante).}
				\notasInfo[inline]{(En algunos países, en vez de elaborarse un censo oficial, son los propios votantes los que han de registrarse)}
				
				
				Es requisito de la Institución que convoca el proceso electoral el definir las ``reglas del juego''. En este caso, el órgano de la EPS encargado de la celebración de las elecciones ha de definir los mecanismos de votación para que el sistema se pueda adaptar y mantener .......
				\todo[inline]{continuar...}
				
				Candidatos. Es necesario que los candidatos puedan presentar su candidatura e incorporarse al sistema para que éste pueda gestionarlos para presentarlos como opciones a los votantes determinados, además de en el momento de consolidación de los votos y posterior publicación de resultados.
				En muchos procesos se realizan desarrollos que permiten a los partidos políticos registrar sus listas electorales y/o candidatos de forma remota durante el plazo determinado que la Ley Electoral les indica. Así, los partidos inscriben a sus representantes en el proceso electoral. En el caso de esta elección, debido a su carácter tan localizado no vemos necesidad de ello y corresponde a la Escuela Politécnica Superior proporcionar el listado de candidatos elegible y las circunscripciones a las que se presentan.
				\todo[inline]{Para futuros desarrollos, pensando en la escalabilidad del sistema, se podría desarrollar este punto para que este proceso sea independiente de los órganos electorales de la EPS}.
				
				En las elecciones tradicionales, es también necesaria la formación de las mesas electorales, con la definición del número de ellas que son necesarias y la designación de los miembros que van a formar parte de ella. En una elección electrónica y remota, como la que hemos diseñado, el concepto de mesa se puede mantener, sobre todo para poder gestionar las circunscripciones y para continuar con las estadísticas de participación tradicionales, basadas en agrupaciones y disgregaciones de mesas. Sin embargo, al transformarse en un concepto lógico, se pierde el sentido de la designación de los miembros de mesa, por lo que no será un punto a tener en cuenta en el proceso.
				
				
				\todo[inline]{Pasamos a la siguiente fase: Identificación}
				Una vez acometidas todas las gestiones de la fase preelectoral, pasamos a la fase correspondiente al llamado Día Electoral (aunque realmente la elección en vez de en un día, se pueda alargar a lo largo de un período de tiempo mayor).
				Tratando de emular a las elecciones tradicionales, esta fase comienza con la apertura de los colegios electorales y las mesas que los componen. En el caso digital, serán los miembros designados por la Junta Electoral los que, previa identificación y requerimiento de sus credenciales digitales, pongan en marcha el sistema en su fase electoral. Será una apertura de los colegios de forma virtual, permitiendo que los votantes puedan acceder al sistema y proceder a votar.
				La fase de identificación del votante es una fase realmente importante. En las elecciones de voto tradicional, el proceso normal consiste en que el votante acude a la mesa electoral y muestra a los miembros de mesa alguna identificación de curso legal, respaldada por alguna institución estatal reconocida y capacitada. Los miembros de la mesa electoral contrastan la identificación presentada con la información recogida en el censo electoral de dicha mesa y deciden si es suficiente o no para permitir al votante introducir su voto en la urna. En el caso de las elecciones legislativas españolas los documentos que se pueden mostrar son DNI, pasaporte o permiso de conducir. Todos estos documentos son válidos para votar incluso estando caducados. Han de mostrar la fotografía del votante para permitir la identificación por parte de los miembros de mesa, por lo que, aunque sea válido que estén caducados, no se permite utilizar el resguardo de DNI en trámite.
				\todo[inline]{En el caso de las elecciones de la EPS, los documentos válidos son .-......}
				Es requisito el sustituir este sistema de identificación del elector por otro en el que no sea necesaria la presencia física de éste ni de los miembros de mesa para permitir el voto, aunque manteniendo el mismo nivel de seguridad en el proceso. Aquí se hace indispensable estudiar las opciones de identificación digital que se pueden implementar para .............
				\todo[inline]{continuar}
				
				Lo ideal es disponer de documentos que contengan tokens criptográficos propios que puedan ser utilizados en los diferentes procesos de identificación y voto. Por ello, vamos a utilizar documentos que los disponen.
				
				Así, los documentos válidos para ejercer el derecho al voto serán el DNIe (tanto la primera versión como la denominada 3.0, presentada en enero de 2015) y la TUI \notasMejorar{***InfoTUI***} de la Universidad San Pablo-CEU. En sendos documentos encontramos elementos criptográficos que identifican unívocamente a su dueño. Además encontramos en ellos certificados para la firma digital, que serán necesarios para la fase de votación.
				
				El votante se identifica con su documento digital de forma remota. Es necesario que disponga de un lector de chip electrónico conectado al dispositivo desde el que va a realizar el voto, aunque utilizando DNIe con lector de chip sin contacto, no haría falta si se hace uso de un dispositivo con sensor de radiofrecuencia, con capacidad para leer información a través de NFC.
				
				A través de la app Android (o la app web), el votante accede al servicio de votación por Internet. El primer paso es la identificación del votante. Es la primera vez que hará uso de los certificados del DNIe. En este caso, la app leerá (con NFC o chip con contacto) el certificado de Autenticación del DNIe, por el cual se asegura la identidad del votante. Con la identidad del votante verificada (por la DGP), se contrasta con el censo, para comprobar:
				\begin{itemize}
					\item Si el votante existe en el censo.
					\item Si el votante ha votado previamente.
					\item Los datos censales del votante, para comprobar circunscripción, mesa electoral y, por ende, ser capaz de obtener los candidatos entre los que puede escoger.
				\end{itemize}
				
				Una vez verificado el votante y comprobados sus datos censales, se procede a construir la boleta con los candidatos que entre los que le corresponde elegir basándose en su circunscripción electoral. El sistema ha de presentar la boleta al votante y permitir que éste marque la o las opciones que permita el sistema electoral para constituir el voto a emitir.
				
				Una vez constituido el voto (papeleta), hay que proceder a la votación digital. Para ello nos basamos en cifrado y firma ciega. Así, el primer paso es que la app utiliza la clave pública de la Entidad Electoral para cifrar el voto. Con el voto cifrado, el votante ha de firmarlo. La firma se realiza con el certificado de Firma que posee el DNIe. Así, el votante firma un conjunto de [voto cifrado + votante], que es el paquete que se pasará al subsistema de gestión del voto.
				
				Una vez el votante ha emitido el voto, el sistema le devuelve un resguardo (código QR como en Estonia, un código alfanumérico, no sé todavía) con el cual puede verificar que el voto ha sido correctamente incluido en el sistema. Además, podrá verificar que el voto ha sido correctamente incluido en el escrutinio. \notasCambio[inline]{(No sé si con este resguardo debe poder llegar a la opción de voto elegida, todo depende de cómo tomemos el requisito de coerción y qué es lo que menos le afecta)}
				
				El votante puede votar tantas veces como desee cambiar su voto \notasInfo{Así disminuimos el riesgo de coerción}. Para ello, hay un protocolo por el cual cuando un votante emite su voto, todos los anteriores son anulados. \todo[inline]{Hay que definir el protocolo para la anulación de votos por 'revoto'}
				
				El sistema de gestión del voto es el encargado de los votos sufragados durante la jornada electoral. El sistema almacena los votos firmados (voto cifrado + votante) en una \textit{urna} digital durante el tiempo que dura la jornada electoral. En caso de recibir un voto de un votante que ya previamente había emitido su voto, debe ser capaz de anular los votos anteriores que éste hubiese sufragado\notasInfo{Como digo antes, hay que definir cómo se hace esto de anular votos emitidos}.
				Una vez que el Administrador del Proceso Electoral da por terminada la Jornada Electoral, los Miembros de la Junta Electoral utilizan sus claves para formar la clave maestra que permite dar por terminada la fase de votación y comenzar con el Escrutinio.
				La primera fase del Escrutinio es que los votos firmados deben ser \textit{anonimizados}. Esto lo vamos a realizar en dos pasos. Primero, comprobamos la validez de la firma del voto firmado. Si la firma se corresponde con u voto a descartar, se elimina. Si la firma es válida, se extrae (abrimos el sobre donde va la info del votante y el sobre con su voto secreto) del contenido del voto firmado tanto el voto cifrado como la información asociada del votante. Por un lado, la información del votante se almacena para sacar un listado de votantes (que podrá compararse con el resultado de votantes del censo). Por otra parte, los votos cifrados pasan a otro almacén ya sin asociación con su votante. Para terminar de separar los votos de sus votantes, pasamos por un proceso anonimizador que ... \todo[inline]{Aquí entra en juego ElGamal y sus amigos o las mixnets}.
				Una vez tenemos los votos separados de sus votantes, procedemos a la siguiente fase del escrutinio, que es la de (abrir el sobre del voto secreto) descifrar el voto. El sistema necesita la clave privada de la Entidad Electoral para descifrar los votos que, recordemos, están cifrados con la clave pública. Con esta clave privada, extraemos el contenido del voto cifrado y obtenemos cada uno de los votos en plano de las urnas digitales.
				Una vez obtenidos el conjunto de los votos en plano de cada urna digital, podemos proceder a la consolidación de los votos. Se realiza el conteo de cada urna y, con los resultados obtenidos, se puede realizar la totalización para llegar al resultado final de la Elección.
				
				El último paso del sistema será el de la Difusión de los Resultados. El sistema de Escrutinio (o Totalización) informa de los resultados al módulo de Difusión, el cual les aplicará el formato necesario para cumplir con las necesidades de publicación de los mismos. En el caso del Proceso Electoral asociado a este proyecto, una web y diversos listados PDFs para poder ser cotejados.

				Sería muy interesante que, como en Estonia, los votantes tuvieran una herramienta para poder verificar que su voto ha sido correctamente incluido y escrutado en el Proceso.
				
				Paralelamente a todo el proceso, cada subsistema ha de generar una serie de registros, ficheros logs, que puedan ser visualizados por un conjunto de auditores, observadores u otro grupo de profesionales que tengan que dar cuenta del correcto funcionamiento del Proceso y de la transparencia del mismo, así como del éxito técnico del Sistema.
\fi		
	
	
	\section{Prototipo}\label{solucion_prototipo}
	Para implementar el software desarrollado en este Proyecto, se decidió montar un prototipo que cumpliera con los requisitos funcionales y diera una muestra de las capacidades del mismo a una escala reducida.
	
	Para ello, había que desarrollar los 3 módulos de software:
		\begin{itemize}
			\item Servidor de votación
			\item Servidor de identificación y autenticación
			\item App Android de identificación con DNIe
		\end{itemize}
	
	
	\subsection{Arquitectura física}\label{solucion_prototipo_arquitecturaFisica}
	Para montar los dos servidores, se decidió pasar de las máquina virtuales en las que se desarrollaron al uso de dos Raspberry Pi como base hardware.
	
	Raspberry Pi es un computador de placa reducida, única o simple de bajo coste desarrollado por la Fundación Raspberry Pi, con base en Reino Unido, con el objetivo de estimular la enseñanza de la informática en las escuelas.
	
	El lanzamiento del primero de los modelos fue a finales de febrero de 2012. Hasta el momento, Raspberry Pi ha comercializado 5 modelos de placas, desde la Raspberry Pi 1 Modelo A en 2012 hasta la Raspberry Pi 3 Modelo B, lanzada en 2016.
	
	Los modelos con los que se ha montado el prototipo son:
	
		\begin{description}
			\item[Servidor de votación]	Raspberry Pi Model 3 B
			\item[Servidor de identificación y autenticación] Raspberry Pi Model B (Rev. 2.0, 512Mb)
		\end{description}
		
		\todo[inline]{Incluir fotos de las raspberrys					}
		
		En la tabla \ref{tab:DetallesTecnicosRaspberryPi} se detallan y comparan las características de ambos modelos de hardware.
		
		\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
		\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
		\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
		\begin{table}[ht]
			%\fontsize{5}{4}\selectfont
			\small
			\def\arraystretch{1.25}%  1 is the default, change whatever you need
			\setstretch{1}
				\begin{threeparttable}
					\centering
						%\begin{tabular*}{0.95\textwidth}{@{\extracolsep{\fill}}|L{0.2\textwidth}|L{0.35\textwidth}|L{0.35\textwidth}|}
						\begin{tabular*}{\textwidth}{| L{0.2\textwidth} | L{0.356\textwidth} | L{0.356\textwidth} |}
							\hline
								
								\begin{center}
								\textbf{Característica}
								\end{center}
								 & 
								 \begin{center}
								 \textbf{Raspberry Pi Model B \\(Rev. 2.0, 512Mb)}
								 \end{center}
									& 
									\begin{center}
									\textbf{Raspberry Pi Model 3 B}
									\end{center}
									 \\
							\hline
								Fecha de lanzamiento & Q4 2012 						& Q1 2016 	\\
							\hline
								Precio\tnote{a} & US\$35 						& US\$35 	\\
							\hline
								SoC (System-on-a-chip) & Broadcom BCM2835 			& Broadcom BCM2837 	\\
							\hline
								CPU & 700 MHz ARM11 ARM1176JZF-S core	& 1.2GHz 64-bit quad-core ARMv8 Cortex-A53 \\
							\hline
								GPU & Broadcom VideoCore IV, OpenGL ES 2.0,OpenVG 1080p30 H.264 high-profile encode/decode, 250 MHz	& Broadcom VideoCore IV, OpenGL ES 2.0,OpenVG 1080p60 H.264 high-profile encode/decode, 400 MHz \\
							\hline
								Memoria SDRAM & 512 MB 			& 1024 MB \\
							\hline
								USB & 2 x USB 2.0 						& 4 x USB 2.0 \\
							\hline
								Salida de vídeo & Composite video, Composite RCA, HDMI 	& HDMI	\\
							\hline
								Salida de audio & Conector de 3.5mm, HDMI	 		& Conector de 3.5mm, HDMI	\\
							\hline
								Almacenamiento & Ranura MicroSD	& Ranura MicroSD \\
							\hline
								Redes & 10/100 Ethernet (RJ-45), WiFi vía USB dongle	& 10/100 Ethernet (RJ-45), WiFi 802.11n integrada, Bluetooth 4.1 \\
								\hline
								Periféricos de bajo nivel & 26 x GPIO pins, Serial Peripheral Interface Bus (SPI), $I^{2}C$, $I^{2}S$, UART	& 40 x GPIO pins, Serial Peripheral Interface Bus (SPI), $I^{2}C$, $I^{2}S$, UART, I2C IDC Pins  \\
							\hline
								Consumo energético & 700 mA, (3.5 W) 			& 800 m(4.0 W) \\
							\hline
								Fuente de alimentación & 5 V (DC) vía Micro USB o pines GPIO	& 5 V (DC) vía Micro USB o pines GPIO \\
							\hline
								Tamaño & 85.0 mm x 56.0 mm x 17 mm	& 85.6 mm x 56.5 mm x 17 mm \\
							\hline
								Peso & 40g	& 45g \\
							\hline
						\end{tabular*}
						\begin{tablenotes}
							\scriptsize
							\item[a] \textbf{Precio}: Precio en el momento de su lanzamiento.
						\end{tablenotes}
						\caption{Detalles técnicos de las Raspberry Pi utilizadas en el prototipo.\label{tab:DetallesTecnicosRaspberryPi}}
					\end{threeparttable}
			\end{table}
		
		El Sistema Operativo elegido para ambos servidores es Raspbian \footnote{\url{https://www.raspberrypi.org/downloads/raspbian/}}, una distribución de GNU/Linux basada en su origen en Debian Wheezy. Al ser un sistema basado en GNU/Linux, se infiere que es software libre y de código abierto. No obstante, para el prototipo, se ha instalado la versión estable de Raspbian a fecha de Noviembre de 2016, en la cual, el Sistema Operativo se basa en la versión de GNU/Linux Debian Jessie \footnote{\url{https://www.raspberrypi.org/blog/raspbian-jessie-is-here/}}, posterior a Wheezy.
		
		\subsection{Arquitectura de red}\label{solucion_prototipo_arquitecturaRed}
		La arquitectura de red propuesta para el prototipo incluye varios elementos:
		\begin{itemize}
			\item Servidor de identificación
			\item Servidor de votación
			\item Dispositivos de votación
			\item Router
		\end{itemize}
		
		Los dos servidores están conectados a la misma red. Particularmente, por motivos de diferencia en los modelos de las dos Raspberry Pis en las que están montados, uno de ellos - el Servidor de Identificación - utilizará un dongle USB de conexión a la red, mientras que el Servidor de Votación hace uso de la placa de red interna de su Raspberry Pi.
		
		En la configuración del sistema se puede optar porque el sistema funcione por Internet o en una Intranet. La idea es que el servicio sea ofrecido por Internet y así se diseñó, pero por motivos de infraestructura a la hora de presentarlo, se decidió desarrollar la posibilidad de funcionar también en una intranet.
		
		Para ello, hay que configurar tanto el router como la app Android y los servidores. En el caso del router, para funcionar por Internet habría que abrir los puertos necesarios y realizar su pertinente redireccionamiento a los puertos de los servidores necesarios.
		
		Una configuración típica de esta forma de conexión a través de Internet incluye configurar estos redireccionamientos en los puertos del router:
		
\iffalse		
		\todo[inline]{Transformar a tabla}
		Puerto del Router - IP del servidor - Puerto del servidor - Necesidad
		8662 - 192.168.1.144 (Servidor Identificación) - 442 - Puerto de acceso al servidor Apache por HTTPS/TLS
		8888 - 192.168.1.144 (Servidor Identificación) - 80 - Acceso al Apache por HTTP sin seguridad
		8443 - 192.168.1.144 (Servidor Identificación) - 443 - Puerto de acceso al servidor Apache por HTTPS/TLS
		8022 - 192.168.1.144 (Servidor Identificación) - 22 - Acceso SSH
		
		8889 - 192.168.1.145 (Servidor Votación) - 80 - Acceso al Apache por HTTP sin seguridad
		8445 - 192.168.1.145 (Servidor Votación) - 443 - Puerto de acceso al servidor Apache por HTTPS/TLS
		8044 - 192.168.1.145 (Servidor Votación) - 22 - Acceso SSH
\fi		

		\begin{table}[]
			\begin{tabularx}{\linewidth}{|l|l|l|l|l|}
				\hline
					\multicolumn{1}{c}{\textbf{Servidor}}	&	\multicolumn{1}{c}{\textbf{Puerto externo}}	&	\multicolumn{1}{c}{\textbf{IP servidor interno}}	&	\multicolumn{1}{c}{\textbf{Puerto interno}}	&	\multicolumn{1}{c}{\textbf{Descripción}}	\tabularnewline
					\hline
					\multirow{4}{*}{Servidor Identificaión} 	& 8662 & 192.168.1.144 & 442 	& Puerto de acceso al servidor Apache por HTTPS/TLS \tabularnewline
					\cline{2-5}
																										& 8888 & 192.168.1.144 & 80 	& Acceso al Apache por HTTP sin seguridad \tabularnewline
					\cline{2-5}
																										& 8443 & 192.168.1.144 & 443 	& Puerto de acceso al servidor Apache por HTTPS/TLS \tabularnewline
					\cline{2-5}
																										& 8022 & 192.168.1.144 & 22 	& Acceso SSH \tabularnewline
					\hline
					\multirow{3}{*}{Servidor Votación}	 			& 8889 & 192.168.1.145 & 80 	& Acceso al Apache por HTTP sin seguridad \tabularnewline
					\cline{2-5}
																										& 8445 & 192.168.1.145 & 443 	& Puerto de acceso al servidor Apache por HTTPS/TLS \tabularnewline
					\cline{2-5}
																										& 8044 & 192.168.1.145 & 22 	& Acceso SSH \tabularnewline
					\hline
			\end{tabularx}
			\caption{Port forwarding en la red de desarrollo.\label{tab:portForfarding}}
		\end{table}
			
		
		
		En caso de la configuración del sistema para trabajar en intranet, por motivos de infraestructura, ya sea por una presentación como la de este propio proyecto o por querer realizar una votación cerrada, la propuesta implementada incluye un router simple funcionando sin conexión a Internet.
		
		El router utilizado ha sido XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX. \todo{incluir modelo del router para la presentación}
		
		